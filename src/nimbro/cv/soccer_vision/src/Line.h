
//------------------------------------------------------------------------------------------------------------------//
//                           Line Detection Class - Part of ObjectRecognition namespace                             //
//------------------------------------------------------------------------------------------------------------------//
//
// This Line Detection algorithm is based on Prof. Sven Behnke's Diplom thesis ( 1997 ) and his original source code.
//
// If you wanna comprehend this class easily, please refer to the commented "Interface" at the bottom of this file.
//
// I wrote the entire class in a single .h file mainly because most C++ compilers, including VC++, doesn't support
// the keyword "export" yet ( VS2008 ). Basically speaking, under these compilers, the bodies of template functions 
// must be made available in a header file. Maybe there's some better way, but why bother! ^_^
//
// Author  : Weichao LIU ( Sean )
// Created : Mar-16-2009
// Last Modified: Apr-10-2009
//

#ifndef OBJECT_RECOGNITION_LINE_H
#define OBJECT_RECOGNITION_LINE_H
#define FIELDLINE_DEBUG_INFO 0

#include <vector>
#include <string.h>
#include <algorithm>
#include <cmath>
#include <cassert>

#include "globaldefinitions.h"
#include "Vec2i.h"
#include "Line_fwd.h"
#include "nimbroStyleTools.h"
#include "pixelCameraCorrection.h"
#include "frameGrabber.h"

// #include <WideAngle_CV.h>

namespace ObjectRecognition {
	
using namespace std;


    // * Static Data of Circle Pixels Look-up Table.                                                  * //
    // * Manually optimized circle pixel table generated by Midpoint Circle Algorithm ( Bresenham )   * //
    // * Origin at (0, 0), start from top middle pixel and end at it again with a clockwise sequence. * //
    // * Coordinate (99, 99) indicates end of this circle.                                            * //
    // * Radius 4, 21 effective elements, 22 in total.
    // * Radius 5, 29 effective elements, 30 in total.
    // * Radius 6, 33 effective elements, 34 in total.
    // * Radius 7, 41 effective elements, 42 in total.
    // * Radius 8, 45 effective elements, 46 in total.
    const static int CIRCLE[5][46][2] = {
        { {0, 4}, {1, 4}, {2, 3}, {3, 2}, {4, 1}, {4, 0}, {4, -1}, {3, -2}, {2, -3}, {1, -4}, {0, -4}, {-1, -4}, {-2, -3}, {-3, -2}, {-4, -1}, {-4,  0}, {-4,  1}, {-3,  2}, {-2,  3}, {-1,  4}, {0,   4}, {99,99}, {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} },
        { {0, 5}, {1, 5}, {2, 5}, {3, 4}, {4, 3}, {5, 2}, {5,  1}, {5,  0}, {5, -1}, {5, -2}, {4, -3}, {3,  -4}, {2,  -5}, {1,  -5}, {0,  -5}, {-1, -5}, {-2, -5}, {-3, -4}, {-4, -3}, {-5, -2}, {-5, -1}, {-5,  0}, {-5,  1}, {-5,  2}, {-4,  3}, {-3,  4}, {-2,  5}, {-1,  5}, {0,   5}, {99,99}, {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} },
        { {0, 6}, {1, 6}, {2, 6}, {3, 5}, {4, 4}, {5, 3}, {6,  2}, {6,  1}, {6,  0}, {6, -1}, {6, -2}, {5,  -3}, {4,  -4}, {3,  -5}, {2,  -6}, {1,  -6}, {0,  -6}, {-1, -6}, {-2, -6}, {-3, -5}, {-4, -4}, {-5, -3}, {-6, -2}, {-6, -1}, {-6,  0}, {-6,  1}, {-6,  2}, {-5,  3}, {-4,  4}, {-3,  5}, {-2,  6}, {-1,  6}, {0,   6}, {99,99}, {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} , {0,0} },
        { {0, 7}, {1, 7}, {2, 7}, {3, 6}, {4, 6}, {5, 5}, {6,  4}, {6,  3}, {7,  2}, {7,  1}, {7,  0}, {7,  -1}, {7,  -2}, {6,  -3}, {6,  -4}, {5,  -5}, {4,  -6}, {3,  -6}, {2,  -7}, {1,  -7}, {0,  -7}, {-1, -7}, {-2, -7}, {-3, -6}, {-4, -6}, {-5, -5}, {-6, -4}, {-6, -3}, {-7, -2}, {-7, -1}, {-7,  0}, {-7,  1}, {-7,  2}, {-6, 3}, {-6, 4}, {-5, 5}, {-4, 6}, {-3, 6}, {-2, 7}, {-1, 7}, {0,  7}, {99,99}, {0,0}, {0,0} , {0,0} , {0,0} }, 
        { {0, 8}, {1, 8}, {2, 8}, {3, 7}, {4, 7}, {5, 6}, {6,  5}, {7,  4}, {7,  3}, {8,  2}, {8,  1}, {8,   0}, {8,  -1}, {8,  -2}, {7,  -3}, {7,  -4}, {6,  -5}, {5,  -6}, {4,  -7}, {3,  -7}, {2,  -8}, {1,  -8}, {0,  -8}, {-1, -8}, {-2, -8}, {-3, -7}, {-4, -7}, {-5, -6}, {-6, -5}, {-7, -4}, {-7, -3}, {-8, -2}, {-8, -1}, {-8, 0}, {-8, 1}, {-8, 2}, {-7, 3}, {-7, 4}, {-6, 5}, {-5, 6}, {-4, 7}, {-3, 7}, {-2, 8}, {-1, 8}, {0, 8}, {99,99} } 
    };

    class Line
    {

    private:

        // ********************* //
        // *     Constants     * //
        // ********************* //
		enum{
			MAX_TRANSITIONS   =  32,
			TRANSITION_TYPE   =   2,
			UNIT              = 512,
			SKEL_THRESHOLD    =  62,
			MAX_CONN          =   4,
			MAX_CLOSE         =  64,
			MAX_TDL_CURVES    =   6,
			MAX_CURVE_ARCS    =  64,
			MAX_GRAPHS        = 128,
			MAX_TOTAL_GRAPHS  = 500,
			MAX_POINTS        = 128,
			NUM_CLASSES       =  12,
			MAX_SET_NUM       =  64,
			MAX_TOTAL_SETS    = 150,
			MAX_COS           = 512,
			LINE_WIDTH        =   4,
			MIN_RADIUS        =   4,
			MAX_RADIUS        =   8,
			CIRCLE_SCALES     = MAX_RADIUS - MIN_RADIUS + 1,
			MATRIX_WIDTH      =  SUB_SAMPLING_WIDTH,
			MATRIX_HEIGHT     =  SUB_SAMPLING_HEIGHT,
			LOWPASS_LINE_1ST  =  10,
			LOWPASS_LINE_2ND  =  25
		};
		
    public:

        // ******************* //
        // * Data Structures * //
        // ******************* //

        // * Node Structure * //
        struct Node {

            int    x_pos;   //<- pixel-coordinates of the node (integer)
            int    y_pos;
            Vec2i  undist_pos;
            float  lambda;
            float  f_x_pos; //<- float-coordinates ...
            float  f_y_pos;
            int    connected[ MAX_CONN ];  //<- edges of the graph, contains num_connected
            // * indices of nodes (undirected, stored twice)
            int    num_connected;          //<- number of edges
            int    close_id [ MAX_CLOSE ]; //<- node-id's of candidates for new connections
            int    close_adj[ MAX_CLOSE ]; //<- eveluation of candidates for new connections
            int    num_close;              //<- number of candidates for new connections
			float  conf;                   // confidence in the crossing_type decision
            enum CrossingType{
                CT_Unknown=0,
                CT_LXing=1,
                CT_TXing=2,
                CT_XXing=3
            };

            CrossingType    crossing_type;

            int    transition_xy[ TRANSITION_TYPE ][ MAX_TRANSITIONS ][ 2 ];
			bool is_connected_to(int nid){
				int* begin = connected;
				int* end   = connected + num_connected;
				return find(begin,end,nid) != end;
			}

        };
        // * Node_Buffer Vector * //
        typedef std::vector< Node > Node_Buffer;

        Node_Buffer * m_NodeBuffer;
		struct LinearGraphComponent;
		vector<LinearGraphComponent> m_Components;


        // * Trans_Buffer Structure * //
        struct Trans_Buffer {

            int arc_cos_sqare[ MAX_COS ]; //<- acos lookup table.

        };

        Trans_Buffer * m_TransBuffer;

        // * Number of corresponding crossings that are found. * //
        int m_L_number;
        int m_T_number;
        int m_X_number;

        // * Boundary Look-up Table * //
        int m_BoundaryForLine[ MATRIX_WIDTH ];
        int m_FieldBoundary[ MATRIX_WIDTH ];
        struct Point {
            int x;
            int y;
        };
        std::vector< Point > m_ConvexStack;
        // * Top pixel of m_BoundaryForLine[] * //
        int m_Top;


        // ************************** //
        // * Constructor/Destructor * //
        // ************************** //

        Line ( )
        {
            m_NodeBuffer  = new Node_Buffer;
            m_TransBuffer = new Trans_Buffer;

            init( );
        };

        ~Line ( )
        {
			m_NodeBuffer->clear();
            delete m_NodeBuffer;
            delete m_TransBuffer;
        };


        // ******************* //
        // * Public Methods  * //
        // ******************* //

        // ****************************************************************************** //
        template < typename T, int W, int H >
        void 
            ScanBoundary ( /* in */ const T ( & mGreen )[ H ][ W ] )
        // ****************************************************************************** //
        {

            // * Reset * //
//            memset( m_BoundaryForLine, 5, sizeof ( unsigned int ) * MATRIX_WIDTH ); //<- Start from the sixth pixel.
            m_Top = 0;

            // * Scan the entire matrix to get m_BoundaryForLine[] for further processing. * //
            int average = 0;
            for ( unsigned int x = 0; x < W; x++ ) { //<- Left to right.
                unsigned int blank = 0; //<- Blank pixel counter.
                unsigned int green = 0;
                for ( unsigned int y = 5; y < H; y++ ) { //<- Bottom-up. Start from the sixth pixel.

                    if ( mGreen[ y ][ x ] > 10 ) { //<- 1/6 of 63 pixels.
                        blank = 0; //<- If a Green pixel, blank counter reset to 0.
                        m_BoundaryForLine[ x ] = green++;
                        continue;
                    }

                    m_BoundaryForLine[ x ] = y - blank; 
                    if ( 4 == ++blank ) { //<- Four continuous blanks found in a column.
                        average += m_BoundaryForLine[ x ];
                        break; //<- Found rough ending, jump out for the next turn.
                    }

                }
            }
            average /= W;

            // * 0. Smooth with Gaussian and 1. Fill the gap with Median to get the final Boundary Look-up Table. * //
            bool bStart = false;
            for ( unsigned int x = 0; x < W - 2; x++ ) {

                if ( !bStart ) {
                    if ( abs( m_BoundaryForLine[ x ] - average ) < 10 ) {
                        bStart = true;
                    }
                    else {
                        continue;
                    }
                }

                if ( abs( m_BoundaryForLine[ x ] - m_BoundaryForLine[ x + 1 ] ) > 2 || 
                     abs( m_BoundaryForLine[ x + 1 ] - m_BoundaryForLine[ x + 2 ] ) > 2    ) { //<- Some gap found, use average value of neighbors.

                         int pre_diff = H, cur_diff;
                         for ( unsigned int xx = 1; xx < 9 && ( x + xx ) < W; xx++ ) { //<- The gap is at most 8 pixels wide.
                             if ( abs( m_BoundaryForLine[ x ] - m_BoundaryForLine[ x + xx ] ) < 4 ) {
                                 m_BoundaryForLine[ x + 1 ] = ( m_BoundaryForLine[ x ] + m_BoundaryForLine[ x + xx ] ) >> 1;
                                 break;
                             }
                             else {
                                 cur_diff = m_BoundaryForLine[ x + xx ] - m_BoundaryForLine[ x ];
                                 if ( abs( cur_diff ) < abs( pre_diff ) ) {
                                     pre_diff = cur_diff;
                                     m_BoundaryForLine[ x + 1 ] = ( ( m_BoundaryForLine[ x ] << 1 ) + cur_diff ) >> 1;
                                 }
                             }

                         }

                }
                else { //<- No gap, use Gaussian filter.
                    m_BoundaryForLine[ x + 1 ] = ( ( m_BoundaryForLine[ x + 1 ] << 1 ) + m_BoundaryForLine[ x ] + m_BoundaryForLine[ x + 2 ] ) >> 2;
                }

                //m_Top = max( m_Top, m_BoundaryForLine[ x + 1 ] );

            }
            // * Process the last 3 pixels. Pick 3 but not 2 for reliability issues.
            int diff = ( m_BoundaryForLine[ W - 4 ] - m_BoundaryForLine[ W - 6 ] ) >> 1 ; //<- Changing gradient
            m_BoundaryForLine[ W - 3 ] = max( 0, m_BoundaryForLine[ W - 4 ] + diff );
            //m_Top = max( m_Top, m_BoundaryForLine[ W - 3 ] );
            m_BoundaryForLine[ W - 2 ] = max( 0, m_BoundaryForLine[ W - 3 ] + diff );
            //m_Top = max( m_Top, m_BoundaryForLine[ W - 2 ] );
            m_BoundaryForLine[ W - 1 ] = max( 0, m_BoundaryForLine[ W - 2 ] + diff );
            //m_Top = max( m_Top, m_BoundaryForLine[ W - 1 ] );

            //m_Top = H - m_Top;

#if _DEBUG
            assert( m_Top <= H );
#endif

            return;

        }; // END of ScanBoundary METHOD


        // ****************************************************************************** //
        template < typename T, int W, int H >
        void 
          ScanField ( /* in */ const T ( & mGreen )[ H ][ W ], /* in */ const T ( & mWhite )[ H ][ W ],/* in */ const T ( & mBlack )[ H ][ W ] )
        // ****************************************************************************** //
        {
            const int          sspNum     = 64; //<- SubSampled pixel number.
		    const int          NoColorG   = sspNum / 4;
//			const int          NoColorW   = 8;
//			const int          NoColorB   = 15;
            const unsigned int MinLengthG = 3;  //<- Minimum length ( in pixels ) of a line segment in subsampled image for Green.
//			const unsigned int MinLengthW = 2;  //<- for White.
//			const unsigned int MinLengthB = 2;  //<- for Black.
			const unsigned int MaxLengthG = 6;  //<- Direct qualified length ( in pixels ) of a line segment in subsampled image for Green.
			const int          MaxBlankG  = 2;  //<- Maximum number of blank pixel(s) in subsampled image for Green.
//			const int          MaxBlankW  = 3;  //<- for White.
//			const int          MaxBlankB  = 4;  //<- for Black.

            struct LineSegment {
                int head;
                int tail;
            };
            const int MaxLineNumber = 6;

            // * [0] Scan line segments for further processing. * //
            LineSegment lnSegsGreen[ W ][ MaxLineNumber ];
//			LineSegment lnSegsWhite[ W ][ MaxLineNumber ];
//			LineSegment lnSegsBlack[ W ][ MaxLineNumber ];
            memset( lnSegsGreen, -1, sizeof( lnSegsGreen ) );
//			memset( lnSegsWhite, -1, sizeof( lnSegsWhite ) );
//			memset( lnSegsBlack, -1, sizeof( lnSegsBlack ) );
/*             Use array instead of vector for performance */
/*             typedef std::vector< LineSegment > LnSegments; */
/*             LnSegments * lnSegsGreen = new LnSegments[ W ]; */
//             int average = 0;
            for ( int x = 0; x < W; x++ ) { //<- Left to right.
                unsigned int blankG = 0; //<- Blank pixel counter.
//				unsigned int blankW = 0;
//				unsigned int blankB = 0;
                unsigned int green = 0;
//				unsigned int white = 0;
//				unsigned int black = 0;
                int headG = 0;
//				int headW = 0;
//				int headB = 0;
                bool startedG = false;
//				bool startedW = false;
//				bool startedB = false;
                int ln_numG = 0;
//				int ln_numW = 0;
//				int ln_numB = 0;
                for ( int y = H - 1; y >= 0; y-- ) { //<- Top-down.

				    // * Green * //
                    if ( mGreen[ y ][ x ] < NoColorG ) {
                        blankG++;
                    }
                    else {
                        if ( !startedG ) {
                            startedG = true;
                            headG    = y;
                        }
                        blankG = 0;
                        green++;
                    }
                    if ( startedG && ( blankG >= MaxBlankG || y == 0 ) ) {
                        if ( green > MinLengthG ) {
                            lnSegsGreen[ x ][ ln_numG   ].head = headG;
                            lnSegsGreen[ x ][ ln_numG++ ].tail = y;
/*                             const LineSegment ln( head, y ); */
/*                             lnSegsGreen[ x ].push_back( ln ); */
                        }
                        startedG = false;
                        if ( green > MaxLengthG || ln_numG == MaxLineNumber ) {
                            break;
                        }
                        green = 0;
                    }

/* 					// * White * // */
/*                     if ( mWhite[ y ][ x ] < NoColorW ) { */
/*                         blankW++; */
/*                     } */
/*                     else { */
/*                         if ( !startedW ) { */
/*                             startedW = true; */
/*                             headW    = y; */
/*                         } */
/*                         blankW = 0; */
/*                         white++; */
/*                     } */
/*                     if ( startedW && ( blankW >= MaxBlankW || y == 0 ) ) { */
/*                         if ( white > MinLengthW ) { */
/*                             lnSegsWhite[ x ][ ln_numW   ].head = headW; */
/*                             lnSegsWhite[ x ][ ln_numW++ ].tail = y; */
/*                         } */
/*                         startedW = false; */
/*                         white = 0; */
/*                         if ( ln_numW == MaxLineNumber ) { */
/*                             break; */
/*                         } */
/*                     } */

/* 					// * Black * // */
/*                     if ( mBlack[ y ][ x ] < NoColorB ) { */
/*                         blankB++; */
/*                     } */
/*                     else { */
/*                         if ( !startedB ) { */
/*                             startedB = true; */
/*                             headB    = y; */
/*                         } */
/*                         blankB = 0; */
/*                         black++; */
/*                     } */
/*                     if ( startedB && ( blankB >= MaxBlankB || y == 0 ) ) { */
/*                         if ( black > MinLengthB ) { */
/*                             lnSegsBlack[ x ][ ln_numB   ].head = headB; */
/*                             lnSegsBlack[ x ][ ln_numB++ ].tail = y; */
/*                         } */
/*                         startedB = false; */
/*                         black = 0; */
/*                         if ( ln_numB == MaxLineNumber ) { */
/*                             break; */
/*                         } */
/*                     } */

                }

            }

            // * [1] Remove Green line segments if it doesn't have certain number of neighboring Green pixels. * //
			const int   WinSizeLUT[ 6 ] = { 10, 9, 8, 7, 6, 5 };
			const float HalfGreenRatio  = .45f;
			const float TotalGreenRatio = .25f;
            for ( int x = 0; x < W; x++ ) { //<- Go from Left to Right through all the columns.
			  for ( int n = 0; n < MaxLineNumber; n++ ) { //<- Go through all line segments in  on column.
				    int & head = lnSegsGreen[ x ][ n ].head;
					int & tail = lnSegsGreen[ x ][ n ].tail;
                    if ( head < 0 ) { //<- No line segment any more.
                        break;
                    }
					int length = head - tail;
					if ( length < 5 ) {
					    length = 5;
					}
					else if ( length > 10 ) {
					    length = 10;
					}
					int width  = WinSizeLUT[ length - 5 ];
					int pix_count_l = 0;
					int pix_count_r = 0;
                    for ( int y = head; y >= tail; y-- ) { //<- Loop Y value of one line segment.
						// * Left * //
						for ( int xx = - width; xx < 0; xx++ ) {
						    if ( x + xx < 0 ) {
							    continue;
							}
						    pix_count_l += mGreen[ y ][ x + xx ];
						}
						// * Right * //
						for ( int xx = width; xx > 0; xx-- ) {
						    if ( x + xx >= W ) {
							    continue;
							}
							pix_count_r += mGreen[ y ][ x + xx ];
						}
                    }
					const float hgrLeft  = ( float ) ( pix_count_l ) / ( float ) ( length * width * sspNum );
					const float hgrRight = ( float ) ( pix_count_r ) / ( float ) ( length * width * sspNum );
					const float tgr      = ( hgrLeft + hgrRight ) / 2.f;
					// * Quantity of neighboring Green pixels is not qualified, remove. * //
					if ( hgrLeft < HalfGreenRatio && hgrRight < HalfGreenRatio && tgr < TotalGreenRatio ) {
					    head = -2;
					    //tail = -2; //<- we only need one negative value.
					}
                }
            }

			// * [2] Remove White line segments if it's not qualified. * //
			// * Main idea: Scan with window of adaptive size.
			// *     1. It should have certain amounts of Green in the window.
			// *     2. The White pixel should be some ratio of the pixels inside the entire window.
			// *     3. Additional - The density of the White blob should be high.
//            for ( int x = 0; x < W; x++ ) { //<- Go from Left to Right through all the columns.
//		        for ( int n = 0; n < MaxLineNumber; n++ ) { //<- Go through all line segments in  on column.
//				}
//			}

			// * [X] Use the Green to improve the existing boundary. * //
			for ( int x = 0; x < W; x++ ) {
			    int & top  = m_FieldBoundary[ x ];
			    if ( lnSegsGreen[ x ][ 0 ].head == -1 ) {
				    top = 0;
					continue;
			    }
				for ( int n = 0; n < MaxLineNumber; n++ ) {
				    int & head = lnSegsGreen[ x ][ n ].head;
				    if ( head < 0 ) {
					    continue;
				    }
					if ( head < top ) {
					    break;
					}
					top = head;
				}
			}

            return;
           
        }; // END of ScanField METHOD


        // ****************************************************************************** //
        void 
            FindLocalConvex( )
        // ****************************************************************************** //
        {
            // * This is an ad hoc convex scan algorithm for detecting local polygon   * //
            // * based on Graham Scan Algorithm and Andrew's Monotone Chain Algorithm. * //

            m_ConvexStack.clear( );
            const Point init  = { 0, m_BoundaryForLine[ 0 ] };
            m_ConvexStack.push_back( init );

//             const int maxGapSize = ( int ) ( MATRIX_WIDTH / 4 ); //<- Maximum size of gap the polygon is allowed to cover.

            int x = init.x + 1;
            while ( x < MATRIX_WIDTH - 1 ) {

                const Point left  = m_ConvexStack.back( );
                const Point p     = {   x, m_BoundaryForLine[ x ] };
                const Point right = { ++x, m_BoundaryForLine[ x ] };

                const int v = ( right.x - left.x ) * ( p.y - left.y ) - ( p.x - left.x ) * ( right.y - left.y );
                if ( v >= 0 ) {
                    m_ConvexStack.push_back( p );
                }

            }

            const int endX = MATRIX_WIDTH - 1;
            if ( m_ConvexStack.back( ).x != endX ) {
                const Point end = { endX, m_BoundaryForLine[ endX ] };
                m_ConvexStack.push_back( end );
            }

            for ( unsigned int i = 0; i < m_ConvexStack.size( ) - 1; i++ ) {
                const int x1 = m_ConvexStack[ i ].x;
                const int y1 = m_ConvexStack[ i ].y;
                const int x2 = m_ConvexStack[ i + 1 ].x;
                const int y2 = m_ConvexStack[ i + 1 ].y;
                bresenham( x1, y1, x2, y2 );
            }

            return;

        }; // END of FindConvexHell METHOD


        // ****************************************************************************** //
        template < typename T, int W, int H >
        void 
            Smooth ( /* in_out */ T ( & matrix )[ H ][ W ], /* out_temp */ T ( & tmp )[ H ][ W ] )
        // ****************************************************************************** //
        {

            memset( tmp, 0, sizeof ( T ) * H * W );

/*
            // * Full Implementation * //

            for ( x = 0; x < W; x++ ) {
                for ( y = InitH + 1; y < H - 1; y++ ) {

                    tmp[ y ][ x ] = ( matrix[ y ][ x ] << 1 ) + matrix[ y - 1 ][ x ] + matrix[ y + 1 ][ x ];
                }
                tmp[ InitH ][ x ] = ( matrix[ InitH ][ x ] << 1 ) + matrix[ InitH + 1 ][ x ];
                tmp[ H - 1][ x ] = ( matrix[ H - 1 ][ x ] << 1 ) + ( matrix[ H - 2][ x ] );
            }

            for ( x = 1; x < W - 1; x++ ) {
                for ( y = InitH; y < H; y++ ) {

                    matrix[ y ][ x ] = ( ( tmp[ y ][ x ] << 1 ) + tmp[ y ][ x - 1 ] + tmp[ y ][ x + 1 ] ) >> 4;
                }
            }
            for ( y = InitH; y < H; y++ ) {
                matrix[ y ][ 0 ] = ( ( tmp[ y ][ 0 ] << 1 ) + tmp[ y ][ 1 ] ) >> 4;
                matrix[ y ][ W - 1 ] = ( ( tmp[ y ][ W - 1 ] << 1 ) + tmp[ y ][ W - 2 ] ) >> 4;
            }
*/
/*
 * Old one for entire matrix before considering boundary.
            // * Low-pass Filter without processing boarders. * //
            int x, y;

            for ( y = H - InitH; y > -1 ; y-- ) {
                for ( x = 1; x < W - 1; x++ ) {

                    tmp[ y ][ x ] = ( matrix[ y ][ x ] << 1 ) + ( matrix[ y ][ x - 1 ] + matrix[ y ][ x + 1 ] );
                }
            }

            for ( x = 0; x < W; x++ ) {

                tmp[ H - InitH ][ x ] = tmp[ 0 ][ x ] = 0;
            }

            for ( y = H - InitH - 1 - 1; y > 0; y-- ) {
                for ( x = 0; x < W; x++ ) {

                    matrix[ y ][ x ] = ( ( tmp[ y ][ x ] << 1 ) + ( tmp[ y - 1 ][ x ] + tmp[ y + 1 ][ x ] ) ) >> 4;
                }
            }
*/

            //m_Top = max( LOWPASS_LINE_1ST, m_Top );
            m_Top = LOWPASS_LINE_1ST;
            // * Low-pass 1st Time. * //
            for ( int y = H - m_Top; y > -1 ; y-- ) {
                for ( int x = 1; x < W - 1; x++ ) {

                    tmp[ y ][ x ] = ( matrix[ y ][ x ] << 1 ) + ( matrix[ y ][ x - 1 ] + matrix[ y ][ x + 1 ] );
                }
            }

            for ( int x = 0; x < W; x++ ) {

                tmp[ H - m_Top ][ x ] = tmp[ 0 ][ x ] = 0;
            }

            for ( int y = H - m_Top - 1 - 1; y > 0; y-- ) {
                for ( int x = 0; x < W; x++ ) {

                    matrix[ y ][ x ] = ( ( tmp[ y ][ x ] << 1 ) + ( tmp[ y - 1 ][ x ] + tmp[ y + 1 ][ x ] ) ) >> 4;
                }
            }
            // * Low-pass 2nd Time. * //
            //m_Top = max( LOWPASS_LINE_2ND, m_Top );
            m_Top = LOWPASS_LINE_2ND;
            for ( int y = H - m_Top; y > -1 ; y-- ) {
                for ( int x = 1; x < W - 1; x++ ) {

                    tmp[ y ][ x ] = ( matrix[ y ][ x ] << 1 ) + ( matrix[ y ][ x - 1 ] + matrix[ y ][ x + 1 ] );
                }
            }

            for ( int x = 0; x < W; x++ ) {

                tmp[ H - m_Top ][ x ] = tmp[ 0 ][ x ] = 0;
            }

            for ( int y = H - m_Top - 1 - 1; y > 0; y-- ) {
                for ( int x = 0; x < W; x++ ) {

                    matrix[ y ][ x ] = ( ( tmp[ y ][ x ] << 1 ) + ( tmp[ y - 1 ][ x ] + tmp[ y + 1 ][ x ] ) ) >> 4;
                }
            }

            return;

        }; // END of Smooth METHOD


        // ****************************************************************************** //
        template < typename T, int W, int H >
        void
            RetrieveSkeleton ( /* in */ const T ( & matrix )[ H ][ W ], /* out */ T ( & output )[ H ][ W ] )
        // ****************************************************************************** //
        {

            memset( output, 0, sizeof ( T ) * H * W );
// 			static bool once = false;
/*
 * Old one for entire matrix.
            unsigned int x, y;
            unsigned int vote;
            int val;
            int InitH = 8;

            for ( x = 1; x < W - 1; x++ ) { // [0]
                for ( y = H - InitH - 1; y > 0; y-- ) {// [1]

                    vote = 0;
                    val = matrix[ y ][ x ];
                    if ( val > SKEL_THRESHOLD ) { // [2]
                        output[ y ][ x ] = 0;
                    }
                    else { // [2]
                        if ( val < matrix[ y ][ x - 1 ] ) { // [3]
                            vote++;
                        }
                        if ( val < matrix[ y ][ x + 1 ] ) { // [3]
                            vote++;
                        }
                        if ( val < matrix[ y - 1 ][ x ] ) { // [3]
                            vote++;
                        }
                        if ( val < matrix[ y + 1 ][ x ] ) { // [3]
                            vote++;
                        }
                        if ( vote < 3 ) { // [3]
                            if ( val <= matrix[ y - 1 ][ x - 1 ] ) { // [4]
                                vote++;
                            }
                            if ( val <= matrix[ y + 1 ][ x - 1 ] ) { // [4]
                                vote++;
                            }
                            if ( vote < 3 ) { // [4]
                                if ( val <= matrix[ y - 1 ][ x + 1 ] ) { // [5]
                                    vote++;
                                }
                                if ( val <= matrix[ y + 1 ][ x + 1 ] ) { // [5]
                                    vote++;
                                }
                                if ( vote < 3 ) { // [5]
                                    output[ y ][ x ] = UNIT + vote; //<- vote := 0...3
                                }
                                else { // [5]
                                    output[ y ][ x ] = 0;
                                }
                            }
                            else { // [4]
                                output[ y ][ x ] = 0;
                            }
                        }
                        else { // [3]
                            output[ y ][ x ] = 0;
                        }
                    } // [2]

                } // [1]
            } // [0]

            for ( y = H - InitH; y > -1; y-- ) { // [0]
                output[ y ][ 0 ] =    output[ y ][ W - 1 ] = 0;
            }

            for ( x = 0; x < W; x++ ) { // [0]
                output[ H - InitH ][ x ] =    output[ 0 ][ x ] = 0;
            }
*/
#ifdef DEBUG
				ofstream myfile("original.txt");
				for(int i = H-1; i >= 0; i--){
					for(int j = 0; j < W; j++){
						myfile<<matrix[i][j]<<"	";
					}
					myfile<<endl;
				}
#endif

            // * Loop through rows. * //
            for ( int x = 1; x < W - 1; x++ ) { // [0]

                // * Loop through columns. * //

                // * Process the pixels under m_BoundaryForLine[x] for skeleton. * //
                for ( int y = 1; y < m_BoundaryForLine[ x ]; y++ ) {// [1]

                    register unsigned int vote = 0;
                    register int val = matrix[ y ][ x ];
                    if ( val > SKEL_THRESHOLD ) { // [2]
                        output[ y ][ x ] = 0;
                    }
                    else { // [2]
                        if ( val < matrix[ y ][ x - 1 ] ) { // [3]
                            vote++;
                        }
                        if ( val < matrix[ y ][ x + 1 ] ) { // [3]
                            vote++;
                        }
                        if ( val < matrix[ y - 1 ][ x ] ) { // [3]
                            vote++;
                        }
                        if ( val < matrix[ y + 1 ][ x ] ) { // [3]
                            vote++;
                        }
                        if ( vote < 3 ) { // [3]
                            if ( val <= matrix[ y - 1 ][ x - 1 ] ) { // [4]
                                vote++;
                            }
                            if ( val <= matrix[ y + 1 ][ x - 1 ] ) { // [4]
                                vote++;
                            }
                            if ( vote < 3 ) { // [4]
                                if ( val <= matrix[ y - 1 ][ x + 1 ] ) { // [5]
                                    vote++;
                                }
                                if ( val <= matrix[ y + 1 ][ x + 1 ] ) { // [5]
                                    vote++;
                                }
                                if ( vote < 3 ) { // [5]
                                    output[ y ][ x ] = UNIT + vote; //<- vote := 0...3
                                }
/*
 * Not necessary because output[][] has already been initialized to zero. Write here for completeness.
                                else { // [5]
                                    output[ y ][ x ] = 0;
                                }
*/
                            }
/*
                            else { // [4]
                                output[ y ][ x ] = 0;
                            }
*/
                        }
/*
                        else { // [3]
                            output[ y ][ x ] = 0;
                        }
*/
                    } // [2]

                } // [1]
/*
                // * Set the pixels above m_BoundaryForLine[x] to be zero. * //
                for ( y = m_BoundaryForLine[ x ]; y < H ; y++ ) { // [1]
                    output[ y ][ x ] = 0;
                }
*/
            } // [0]
/*
            for ( y = 0; y < H; y++ ) { // [0]
                output[ y ][ 0 ] =    output[ y ][ W - 1 ] = 0;
            }

            for ( x = 0; x < W; x++ ) { // [0]
                output[ 0 ][ x ] = 0;
            }

*/
#ifdef DEBUG
			ofstream myfile2("output.txt");
				for(int i = H-1; i >=0; i--){
					for(int j = 0; j < W; j++){
						if(output[i][j])
							myfile2<<"1"<<"1";
						else
							myfile2<<" "<<"	";
					}
					myfile2<<endl;
				}
#endif
            return;

        }; // END of RetrieveSkeleton METHOD


        // ****************************************************************************** //
        template < typename T, int W, int H >
        void
            FindNodes ( /* in_out */ T ( & matrix )[ H ][ W ], /* out_temp */ T ( & tmp )[ H ][ W ] /* OUT Node_Buffer * m_NodeBuffer, */ )
        // ****************************************************************************** //
        {

            memset( tmp, 0, sizeof ( T ) * H * W );

//            m_NodeBuffer->clear( ); //<- Clear Node_Buffer for a new turn.

            // * For each type of skeleton-pixels (peeks, 2 x ridges) do .... * //
            for ( int i = 0; i < 3; i++ ) { // [0]

                for ( int y = H - 2; y > 0; y-- ) { // [1]
                    for ( int x = 1; x < W - 1; x++ ) { // [2]


                        // * UNIT+i indicates, that skeleton-pixel belongs to type 'i'. * //
                        if ( matrix[ y ][ x ] == UNIT + i ) { // [3]

                            const int num = m_NodeBuffer->size( );
/*
                            if ( num == MAX_NODES_NUM - 1 ) {
                                break;
                            }
*/
                            // * Create new node at position (x,y). * //
                            Node node;
                            node.x_pos = x;
                            node.y_pos = y;
                            node.num_connected = 0;
                            node.num_close = 0;
                            node.crossing_type = Node::CT_Unknown;
                            m_NodeBuffer->push_back(node);

                            // * Examine the 3*3 Neighborhood of the new node.  * //
                            for ( int dy = -1; dy < 2; dy++ ) { // [4]
                                for ( int dx = -1; dx < 2; dx++ ) { // [5]

                                    const int yp = y + dy;
                                    const int xp = x + dx;
                                    const int val = matrix[ yp ][ xp ];

                                    // * Two node-neighborhoods are overlapping. * //
                                    if ( ( val > 0 ) && ( val < UNIT ) ) { // [6]
                                        // * The corresponding indicator (val+UNIT*2) is set. * //
                                        matrix[ yp ][ xp ] += UNIT * 2;
                                        tmp[ yp ][ xp ] = num;
                                    }
                                    // * A 'clean' skeleton-pixel in the neighborhood of the new node is detected and marked. * //
                                    else if ( val >= UNIT && val < UNIT * 2 ) { // [6]
                                        matrix[ yp ][ xp ] = num + 1;
                                    }
                                    // * Three node-neighborhoods are overlapping, the corresponding marker is set. * //
                                    else if ( val >= UNIT * 2 ) { // [6]
                                        matrix[ yp ][ xp ] = UNIT * 3;
                                    }
                                } // [5]
                            } // [4]
                        } // [3]
/*
                        if ( num == MAX_NODES_NUM - 1 ) { // [3]
                            break;
                        }
*/
                    } // [2]
                } // [1]

            } // [0]
            // * Connect all nodes where exactly 2 neighborhoods overlap. * //
            for ( int y = H - 2; y > 0; y-- ) { // [0]
                for ( int x = 1; x < W - 1; x++ ) { // [1]

                    const int val = matrix[ y ][ x ];

                    if ( ( val > UNIT * 2 ) && ( val < UNIT * 3 ) ) {
                        if ( !is_connected( ( val - ( UNIT * 2 + 1 ) ), ( tmp[ y ][ x ] ) ) ) {
                             connect_nodes( ( val - ( UNIT * 2 + 1 ) ), ( tmp[ y ][ x ] ) );
                        }
                    }

                } // [1]
            } // [0]

            return;

        }; // END of FindNodes METHOD


        // ****************************************************************************** //
        template < typename T, int W, int H >
        void
            ConnectTouchingNodes ( /* in */ const T ( & matrix )[ H ][ W ] /* IN_OUT Node_Buffer * m_NodeBuffer, */ )
        // ****************************************************************************** //
        {

            // * Examine the whole skeleton * //
            for ( int y = H - 2; y > 0; y-- ) { // [1]
                for ( int x = 1; x < W - 1; x++ ) { // [0]

                    int value = matrix[ y ][ x ];

                    // * Is (x,y) in a non-overlapping node-neighborhood ? * //
                    if ( ( value > 0 ) && ( value < UNIT ) ) { // [2]
                        int last_val = 0;
                        int value_id = value - 1;

                        // * Examine parts of the neighborhood * //
                        for ( int dy = 0; dy < 3; dy++ ) { // [3]
                            for ( int dx = 0; dx < 2; dx++ ) { // [4]

                                if ( ( dx == 0 ) && ( dy < 2 ) ) { // [5]
                                    continue;
                                }
                                int val = matrix[ y + dy - 1 ][ x + dx ];

                                // * Is neighbor-pixel in a non-overlapping node-neighborhood AND
                                // * neighbor-pixel != actual pixel AND no connection has just been established ? * //
                                if ( ( val > 0 ) && ( val < UNIT ) && ( val != value ) && ( val != last_val ) ) { // [5]
                                    last_val = val;
                                    val--;
                                    // * Connect them, if they're not already connected * //
                                    if ( !is_connected( val, value_id ) ) { // [6]
                                         connect_nodes( val, value_id );
                                    }

                                } // [5]

                            } // [4]
                        } // [3]

                    } // [2]

                } // [1]
            } // [0]

            return;

        }; // END of ConnectTouchingNodes METHOD


        // ****************************************************************************** //
        template < typename T, int W, int H >
        void
            FindMoreNodes ( /* in */ const T ( & matrix )[ H ][ W ] /* IN_OUT Node_Buffer * m_NodeBuffer, */ )
        // ****************************************************************************** //
        {

/*
 * This regular version of vector manipulation has one problem in some cases when void std::vector::push_back()
 * _returns_, it somehow changes the outmost std::vector::iterator.
 * Therefore, I have to use index approach to process the vector.

            int i = -1, j;
            int x, y;
            int dx, dy, ddx, ddy;

            // * For all nodes do ... * //
            Node_Buffer::iterator it;
            for ( it = m_NodeBuffer->begin( ); it != m_NodeBuffer->end( ); it++ ) { // [0]
                i++;

                // * Skip for nodes of degree > 1 * //
                if ( it->num_connected > 1 ) { // [1]
                    continue;
                }

                // * Try to split nodes with degree 0 into two with degree 1 * //
                if ( it->num_connected == 0 ) { // [1]

                    // * Examine the 'far' neighborhood of the node * //
                    for ( dy = -1; dy < 2; dy += 2 ) { // [2]
                        for ( dx = -1; dx < 2; dx += 2 ) { // [3]

                            x = it->x_pos + dx;
                            y = it->y_pos + dy;

                            // * Is (x,y) a skeleton-pixel ? * //
                            if ( matrix[ y ][ x ] > 0 ) { // [4]

                                // * Create new node at (x,y), connect it to the examined one * //
                                Node node;
                                node.x_pos = x;
                                node.y_pos = y;
                                node.num_connected = 0;
                                node.num_close = 0;

                                m_NodeBuffer->push_back( node );
                                connect_nodes( i, m_NodeBuffer->size( ) - 1 );

                                break;
                            } // [4]

                        } // [3]

                        if ( it->num_connected != 0 ) { // [3]
                            break;
                        }
                    } // [2]

                } // [1]

                // * Try to move nodes with degree 1 to the end of the skeleton - line * //
                if ( it->num_connected == 1 ) { // [1]

                    j = it->connected[ 0 ];

                    // * Chose (x,y) in the continued direction of node_j -> node_i * //
                    dx = it->x_pos - ( * m_NodeBuffer )[ j ].x_pos;
                    if ( abs( dx ) > 1 ) { // [2]
                        dx /= 2;
                    }
                    dy = it->y_pos - ( * m_NodeBuffer )[ j ].y_pos;
                    if ( abs( dy ) > 1 ) { // [2]
                        dy /= 2;
                    }
                    x = it->x_pos + dx;
                    y = it->y_pos + dy;

                    // * Is (x,y) skeleton-pixel ? Move node_i to new position * //
                    if ( matrix[ y ][ x ] > 0 ) { // [2]
                        it->x_pos = x;
                        it->y_pos = y;
                    }
                    // * If not, examine a small neighborhood of (x,y) * //
                    else { // [2]

                        for ( ddy = -1; ddy < 2; ddy++ ) { // [3]
                            for ( ddx = -1; ddx < 2; ddx++ ) { // [4]

                                if ( abs( ddx ) + abs( ddy ) != 1 ) { // [5]
                                    continue;
                                }
                                x = it->x_pos + dx + ddx;
                                y = it->y_pos + dy + ddy;

                                // * Don't move to the same position * //
                                if ( ( x == it->x_pos ) && ( y == it->y_pos ) ) { // [5]
                                    continue;
                                }
                                // * Is (x_n, y_n) a skeleton-pixel ? Move node_i to (x_n, y_n) * //
                                if ( matrix[ y ][ x ] > 0 ) { // [5]
                                    it->x_pos = x;
                                    it->y_pos = y;
                                    break;
                                }
                            } // [4]
                            if ( ddy < 2 ) { // [4]
                                break;
                            }
                        } // [3]

                    } // [2]

                } // [1]

            } // [0]
*/

            // * For all nodes do ... * //
            for ( unsigned int i = 0; i < m_NodeBuffer->size( ); i++ ) { // [0]

                // * 0. Skip for nodes of degree > 1 * //
                if ( ( * m_NodeBuffer )[ i ].num_connected > 1 ) { // [1]
                    continue;
                }

                // * 1. Try to split nodes with degree 0 into two with degree 1 * //
                if ( ( * m_NodeBuffer )[ i ].num_connected == 0 ) { // [1]

                    // * Examine the 'far' neighborhood of the node * //
                    for ( int dy = -1; dy < 2; dy += 2 ) { // [2]
                        for ( int dx = -1; dx < 2; dx += 2 ) { // [3]

                            const int x = ( * m_NodeBuffer )[ i ].x_pos + dx;
                            const int y = ( * m_NodeBuffer )[ i ].y_pos + dy;

                            // * Is (x,y) a skeleton-pixel ? * //
                            if ( matrix[ y ][ x ] > 0 ) { // [4]

                                // * Create new node at (x,y), connect it to the examined one * //
                                Node node;
                                node.x_pos = x;
                                node.y_pos = y;
                                node.num_connected = 0;
                                node.num_close = 0;

                                m_NodeBuffer->push_back( node );
                                connect_nodes( i, m_NodeBuffer->size( ) - 1 );

                                break;
                            } // [4]

                        } // [3]

                        if ( ( * m_NodeBuffer )[ i ].num_connected != 0 ) { // [3]
                            break;
                        }
                    } // [2]

                } // [1]

                // * 2. Try to move nodes with degree 1 to the end of the skeleton - line * //
                if ( ( * m_NodeBuffer )[ i ].num_connected == 1 ) { // [1]

                    int j = ( * m_NodeBuffer )[ i ].connected[ 0 ];

                    // * Chose (x,y) in the continued direction of node_j -> node_i * //
                    int dx = ( * m_NodeBuffer )[ i ].x_pos - ( * m_NodeBuffer )[ j ].x_pos;
                    if ( abs( dx ) > 1 ) { // [2]
                        dx /= 2;
                    }
                    int dy = ( * m_NodeBuffer )[ i ].y_pos - ( * m_NodeBuffer )[ j ].y_pos;
                    if ( abs( dy ) > 1 ) { // [2]
                        dy /= 2;
                    }
                    int x = ( * m_NodeBuffer )[ i ].x_pos + dx;
                    int y = ( * m_NodeBuffer )[ i ].y_pos + dy;
                    x = min( MATRIX_WIDTH - 1, x );    
                    x = max( 0,                x );
                    y = min( MATRIX_HEIGHT - 1, y );
                    y = max( 0,                 y );

                    // * Is (x,y) skeleton-pixel ? Move node_i to new position * //
                    if ( matrix[ y ][ x ] > 0 ) { // [2]
                        ( * m_NodeBuffer )[ i ].x_pos = x;
                        ( * m_NodeBuffer )[ i ].y_pos = y;
                    }
                    // * If not, examine a small neighborhood of (x,y) * //
                    else { // [2]

                        for ( int ddy = -1; ddy < 2; ddy++ ) { // [3]
                            for ( int ddx = -1; ddx < 2; ddx++ ) { // [4]

                                if ( abs( ddx ) + abs( ddy ) != 1 ) { // [5]
                                    continue;
                                }
                                x = ( * m_NodeBuffer )[ i ].x_pos + dx + ddx;
                                y = ( * m_NodeBuffer )[ i ].y_pos + dy + ddy;
                                x = min( MATRIX_WIDTH - 1, x );
                                x = max( 0,                x );
                                y = min( MATRIX_HEIGHT - 1, y );
                                y = max( 0,                 y );

                                // * Don't move to the same position * //
                                if ( ( x == ( * m_NodeBuffer )[ i ].x_pos ) && ( y == ( * m_NodeBuffer )[ i ].y_pos ) ) { // [5]
                                    continue;
                                }
                                // * Is (x_n, y_n) a skeleton-pixel ? Move node_i to (x_n, y_n) * //
                                if ( matrix[ y ][ x ] > 0 ) { // [5]
                                    ( * m_NodeBuffer )[ i ].x_pos = x;
                                    ( * m_NodeBuffer )[ i ].y_pos = y;
                                    break;
                                }
                            } // [4]
                            if ( ddy < 2 ) { // [4]
                                break;
                            }
                        } // [3]

                    } // [2]

                } // [1]

            } // [0]

            return;

        }; // END of FindMoreNodes METHOD


        // ****************************************************************************** //
        template < typename T, int W, int H >
        void
            FindCloseNodes ( /* in */ const T ( & matrix )[ H ][ W ] /* IN const Trans_Buffer * m_TransBuffer, */ /* IN_OUT Node_Buffer * m_NodeBuffer, */ )
        // ****************************************************************************** //
        {

            int i = -1, j = -1;
            int rad;
            int fac; //<- Indicates the size of the gaps, which may be closed.
            int ang, dist;

            fac = ( H >> 2 ) + LINE_WIDTH * 2;
            rad = max<int>( 6, ( LINE_WIDTH ) );
            rad = rad * rad;

            // * For all nodes do .... * //
            Node_Buffer::iterator it;
            for ( it = m_NodeBuffer->begin( ); it != m_NodeBuffer->end( ); it++ ) { // [0]
                i++;
                j = -1;

                it->num_close = 0;

                // * Skip all nodes with degree >2. * //
                if ( it->num_connected > 2 ) { // [1]
                    continue;
                }
                // * Continue, if degree(node)=2 AND angle too large. * //
                if ( ( it->num_connected == 2 ) &&
                    ( angle_nodes( it->connected[ 0 ], i, it->connected[ 1 ] ) > 90 ) ) { // [1]
                        continue;
                }

                // * Examine all other nodes. * //
                Node_Buffer::iterator it2;
                for ( it2 = m_NodeBuffer->begin( ); it2 != m_NodeBuffer->end( ); it2++ ) { // [1*]
                    j++;

                    if ( it2 == it ) { // [2]
                        continue;
                    }
                    if ( it2->num_connected == MAX_CONN ) { // [2]
                        continue;
                    }

                    // * If distance between node_i and node_j is too large or if they are connected, continue. * //
                    dist = distance_nodes( i, j );
                    if ( dist > rad ) { // [2]
                        continue;
                    }
                    if ( is_connected( i, j ) ) { // [2]
                        continue;
                    }
                    if ( it->num_close == MAX_CLOSE ) { // [2]
                        break;
                    }
                    // * If a small loop would be produced, continue. * //
                    if ( closes_loop( i, j ) ) { // [2]
                        continue;
                    }
                    if ( it->num_connected == 1 ) { // [2]
                        // * If angle (node_k->node-i) with new edge (node_i->node-j) is too small, continue. * //
                        if ( ( ang = angle_nodes( it->connected[ 0 ], i, j ) ) < 60 ) { // [2]
                            continue;
                        }
                    }
                    else if ( it->num_connected == 2 ) { // [2]
                        // * If angle MIN((node_k1->node-i), (node_k2->node-i)) with new edge
                        // * (node_i->node-j) is too small, continue. * //
                        if ( ( ang = min( angle_nodes( it->connected[ 0 ], i, j ), angle_nodes( it->connected[ 1 ], i, j ) ) ) < 60 ) { // [3]
                                continue;
                        }

                    }
                    else { // [2]
                        ang = 120;
                    }

                    // * Evaluate the significance (adj) of the new edge. * //
                    it->close_id[ it->num_close ] = j;
                    it->close_adj[ it->num_close ] = fac * ( ang - 60 ) *
                        black_line_value( matrix, i, j ) / ( dist + 1 );
                    it->num_close++;

                    if ( it->num_close == MAX_CLOSE ) { // [2]
                        break;
                    }

                } // [1*]

            } // [0]

            return;

        }; // END of FindCloseNodes METHOD


        // ****************************************************************************** //
        template < typename T, int W, int H >
        void
            ConnectCloseNodes ( /* in */ const T ( & matrix )[ H ][ W ] /* IN const Trans_Buffer * m_TransBuffer, */ /* IN_OUT Node_Buffer * m_NodeBuffer, */ )
        // ****************************************************************************** //
        {

            int min_adj;
            int adj, max_adj;
            int i, j, k, l, max_i = 0, max_j = 0;
            int num_j, angle, max_angle, min_angle;
            int iteration = 0;
            int num_ends = 0;

            // * compute the number of open ends. * //
            Node_Buffer::iterator it;
            for ( it = m_NodeBuffer->begin( ); it != m_NodeBuffer->end( ); it++ ) {
                if ( it->num_connected < 2 ) {
                    num_ends += 2 - it->num_connected;
                }
            }
            // * find the best candidate connection and connect the nodes i and j, until termination
            // * condition is TRUE. * //
            do {
                min_adj = max( 100000, 500000 - ( 100000 * ( int ) num_ends ) );
                max_adj = min_adj;

                i = -1;
                // * for all nodes ... * //
                for ( it = m_NodeBuffer->begin( ); it != m_NodeBuffer->end( ); it++ ) {
                    i++;

                    // * for all candidates ... * //
                    for ( k = 0; k < it->num_close; k++ ) {

                        j = it->close_id[ k ];
                        adj = it->close_adj[ k ];

                        num_j = ( * m_NodeBuffer )[ j ].num_connected;

                        if ( num_j != 2 ) {
                            adj += adj / 2;
                        }
                        max_angle = 90;
                        min_angle = 90;

                        for ( l = 0; l < num_j; l++ ) {
                            angle = angle_nodes( i, j, ( * m_NodeBuffer )[ j ].connected[ l ] );
                            if ( angle > max_angle ) {
                                max_angle = angle;
                            }
                            else if ( angle < min_angle ) {
                                min_angle = angle;
                            }
                        }
                        adj += ( adj * ( max_angle - 90 ) ) / 90;
                        adj += ( adj * min_angle ) / 90;

                        if ( closes_loop( i, j ) ) {
                            continue;
                        }
                        if ( adj > max_adj ) {
                            max_adj = adj, max_i = i, max_j = j;
                        }
                    }
                }
                // * If the best candidate is good enough, insert it. * //
                if ( max_adj > min_adj ) {

                    // *  update the number of open ends. * //
                    if ( ( * m_NodeBuffer )[ max_i ].num_connected < 2 ) {
                        num_ends--;
                    }
                    if ( ( * m_NodeBuffer )[ max_j ].num_connected < 2 ) {
                        num_ends--;
                    }
                    connect_nodes( max_i, max_j );

                    update_close_nodes( matrix, max_i );
                    if ( ( * m_NodeBuffer )[ max_j ].num_connected < 4 ) {
                        update_close_nodes( matrix, max_j );
                    }
                    iteration = 0;
                }
                else {
                    if ( iteration == 0 ) {
                        FindCloseNodes( matrix );
                    }
                    iteration++;
                }
            } while ( max_adj > min_adj || iteration < 2 );

            return;

        }; // END of ConnectCloseNodes METHOD


        // ****************************************************************************** //
        void
            SmoothNodes ( /* IN_OUT Node_Buffer * m_NodeBuffer, */ )
        // ****************************************************************************** //
        {

            int j, k;

            Node_Buffer::iterator it;
            for ( it = m_NodeBuffer->begin( ); it != m_NodeBuffer->end( ); it++ ) {

                if ( it->num_connected != 2 ) {
                    it->f_x_pos = ( float ) it->x_pos;
                    it->f_y_pos = ( float ) it->y_pos;
                    continue;
                }
                it->f_x_pos = ( float ) it->x_pos * 2;
                it->f_y_pos = ( float ) it->y_pos * 2;

                for ( j = 0; j < it->num_connected; j++ ) {
                    k = it->connected[ j ];

                    it->f_x_pos += ( * m_NodeBuffer )[ k ].x_pos;
                    it->f_y_pos += ( * m_NodeBuffer )[ k ].y_pos;
                }
            }
            for ( it = m_NodeBuffer->begin( ); it != m_NodeBuffer->end( ); it++ ) {

                if ( it->num_connected != 2 ) {
                    continue;
                }
                it->f_x_pos /= 4.0;
                it->f_y_pos /= 4.0;
            }

            return;

        }; // END of SmoothNodes METHOD


        // ****************************************************************************** //
        void
            DeleteNodes ( /* IN const Trans_Buffer * m_TransBuffer, */ /* IN_OUT Node_Buffer * m_NodeBuffer, */ /* in */ const int H )
        // ****************************************************************************** //
        {

            int i, j, k, l, m, n;
            int max_angle;
            int counter;
            int del, ang;
            int num_j, num_k;
            float min_dist, max_dist, dist;
            float dist_j, dist_k;
            int a;
            int min_ang;
            int angle;

            // * Parameter indicating 'large' or 'small', depending on the size of the image. * //
            max_dist = ( float ) max( 9.0, ( H * H ) / 128.0 );
            ang = 180;

            // * try to delete nodes for decreasing values of ang * //
//            do { // [0]
                counter = 0;
                Node_Buffer::iterator it_i;
                i = -1;
                for ( it_i = m_NodeBuffer->begin( ); it_i != m_NodeBuffer->end( ); it_i++ ) { // [1]
                    i++;

                    // * If deg(node_i)=2 do ... * //
                    if ( it_i->num_connected == 2 ) { // [2]

                        del = 0;

                        j = it_i->connected[ 0 ];
                        num_j = ( * m_NodeBuffer )[ j ].num_connected;

                        k = it_i->connected[ 1 ];
                        num_k = ( * m_NodeBuffer )[ k ].num_connected;

                        dist_j = f_distance_nodes( i, j );
                        dist_k = f_distance_nodes( i, k );
                        min_dist = min( dist_j, dist_k );

                        if ( min_dist < max_dist ) { // [3]
                            min_ang = 90, angle = ang - 30;
                        }
                        else { // [3]
                            min_ang = 120, angle = ang;
                        }
                        if ( ( dist_k < max_dist * 2 ) && ( ( num_k == 1 ) || ( num_k >= 3 ) ) ) { // [3]
                            angle -= 10, min_ang -= 20;
                        }
                        if ( ( dist_j < max_dist * 2 ) && ( ( num_j == 1 ) || ( num_j >= 3 ) ) ) { // [3]
                            angle -= 10, min_ang -= 20;
                        }
                        // * If angle at node_i is large, delete node_i. * //
                        if ( ( a = ( int ) f_angle_nodes( j, i, k ) ) > angle ) { // [3]
                            del = 1;
                        }
                        // * If angle at node_i is small, don't delete node_i. * //
                        else { // [3]

                            if ( a < min_ang ) { // [4]
                                continue;
                            }

                            // * Look at nodes that have a distance of 2 to node_i. * //
                            if ( ( num_j > 1 ) && ( dist_j < max_dist * 2 ) ) { // [4]
                                max_angle = 0;
                                for ( n = 0; n < num_j; n++ ) { // [5]

                                    if ( ( l = ( * m_NodeBuffer )[ j ].connected[ n ] ) == i ) { // [6]
                                        continue;
                                    }
                                    a = ( int ) f_angle_nodes( k, i, l );
                                    if ( a > max_angle ) { // [6]
                                        max_angle = a;
                                    }
                                }
                                if ( max_angle > angle ) { // [5]
                                    del = 1;
                                }

                            } // [4]

                            if ( ( del == 0 ) && ( num_k > 1 ) && ( dist_k < max_dist * 2 ) ) { // [4]
                                max_angle = 0;
                                for ( n = 0; n < num_k; n++ ) { // [5]

                                    if ( ( l = ( * m_NodeBuffer )[ k ].connected[ n ] ) == i ) { // [6]
                                        continue;
                                    }
                                    a = ( int ) f_angle_nodes( j, i, l );
                                    if ( a > max_angle ) { // [6]
                                        max_angle = a;
                                    }
                                }
                                if ( max_angle > angle ) { // [5]
                                    del = 1;
                                }

                            } // [4]

                        } // [3]

                        // * if node_i is detected for deletion,
                        // * check some conditions that prevent node_i from being deleted. * //
                        if ( del ) {  // [3] //<- don't delete, if the resultiong edge is too long.

                            if ( ( dist_j + dist_k > max_dist * 6 ) && ( dist_k > max_dist * 2 ) && ( dist_j > max_dist * 2 ) ) { // [4]
                                continue;
                            }
                            // * don't delete, if an accute angle would be produced. * //
                            if ( num_j == 2 ) { // [4]

                                if ( ( * m_NodeBuffer )[ j ].connected[ 0 ] == i ) { // [5]
                                    l = ( * m_NodeBuffer )[ j ].connected[ 1 ];
                                }
                                else { // [5]
                                    l = ( * m_NodeBuffer )[ j ].connected[ 0 ];
                                }
                                if ( ( f_angle_nodes( l, j, k ) <= 100 ) && ( f_angle_nodes( l, j, i ) > 100 ) ) { // [5]
                                    continue;
                                }

                            } // [4]

                            if ( num_k == 2 ) { // [4]

                                if ( ( * m_NodeBuffer )[ k ].connected[ 0 ] == i ) { // [5]
                                    l = ( * m_NodeBuffer )[ k ].connected[ 1 ];
                                }
                                else { // [5]
                                    l = ( * m_NodeBuffer )[ k ].connected[ 0 ];
                                }
                                if ( ( f_angle_nodes( l, k, j ) <= 100 ) && ( f_angle_nodes( l, k, i ) > 100 ) ) { // [5]
                                    continue;
                                }

                            } // [4]

                            // * delete node_i by removing it's connections. * //
                            disconnect_nodes( i, j );
                            disconnect_nodes( i, k );
                            if ( !is_connected( j, k ) ) { // [4]
                                connect_nodes( j, k );
                            }
                            counter++;

                        } // [3]

                    }  // [2]

                    // * if node_i is an end of a line. * //
                    else if ( it_i->num_connected == 1 ) {  // [2]

                        j = it_i->connected[ 0 ];

                        // * delete node_i, if there is a joint, or a cross near by. * //
                        if ( ( * m_NodeBuffer )[ j ].num_connected < 3 ) {  // [3]
                            continue;
                        }
                        if ( ( ( * m_NodeBuffer )[ j ].num_connected == 3 ) && ( f_distance_nodes( i, j ) > max_dist ) ) {  // [3]
                            continue;
                        }
                        if ( ( ( * m_NodeBuffer )[ j ].num_connected == 4 ) && ( f_distance_nodes( i, j ) > max_dist / 2 ) ) {  // [3]
                            continue;
                        }
                        disconnect_nodes( i, j );

                        counter++;

                    }  // [2]

                    // * if node_i is a joint. * //
                    else if ( it_i->num_connected == 3 ) {  // [2]
                        min_dist = FLT_MAX; //<- maximum distance.
                        j = -1;
                        for ( k = 0; k < 3; k++ ) {  // [3]
                            m = it_i->connected[ k ];

                            dist = f_distance_nodes( i, m );

                            if ( ( ( * m_NodeBuffer )[ m ].num_connected == 3 ) && ( dist < min_dist ) ) {  // [4]
                                j = m, min_dist = dist;
                            }

                        }  // [3]

                        // * try to detect and merge two connected joints to a cross, if they are close. * //
                        if ( j > -1 ) {  // [3]

                            if ( min_dist > max_dist * 3 ) {  // [4]
                                continue;
                            }
                            disconnect_nodes( i, j );

                            num_j = ( * m_NodeBuffer )[ j ].num_connected;

                            for ( m = 0; m < num_j; m++ ) {  // [4]
                                l = ( * m_NodeBuffer )[ j ].connected[ 0 ];
                                disconnect_nodes( j, l );
                                if ( !is_connected( i, l ) ) {  // [5]
                                    connect_nodes( i, l );
                                }

                            } // [4]

                            it_i->f_x_pos = ( float ) ( ( it_i->f_x_pos + ( * m_NodeBuffer )[ j ].f_x_pos ) / 2.0 );
                            it_i->f_y_pos = ( float ) ( ( it_i->f_y_pos + ( * m_NodeBuffer )[ j ].f_y_pos ) / 2.0 );

                            counter++;

                        }  // [3]

                    }  // [2]

                }  // [1]

                if ( ang >= 155 ) {  // [1]
                    ang -= 5;
                }

//            } while ( counter > 0 || ang >= 155 );   // [0]


            Node_Buffer::iterator it;
        /*
            // * Remove Nodes that are not surrounded by Green. * //
            i = -1;
            int green_count;

            for ( it = m_NodeBuffer->begin( ); it != m_NodeBuffer->end( ); it++ ) { // [0]
                i++;

                if ( 0 == it->num_connected ) { // [1]
                    continue;
                }

                green_count = 0;

                if ( it->x_pos > 2 && it->x_pos < W - 2 && it->y_pos < H - 2 ) { // [1]

                    for ( int y = -2; y < 3; y++ ) { // [2]
                        for ( int x = -2; x < 3; x++ ) { // [3]

                            if ( matrix[ it->y_pos + y ][ it->x_pos + x ] > 0 ) { // [4]
                                green_count++;
                            }

                        } // [3]
                    } // [2]

                } // [1]

                if ( green_count < 5 ) { // [1]

                    for ( int ind = 0; ind < it->num_connected; ind++ ) { // [2]

                        disconnect_nodes( m_NodeBuffer, i, it->connected[ ind ] );
                    }

                } // [1]

            } // [0]
        */

            // * Merge nodes that are too close. * //
            i = -1;
            int tmp = 0;
            for ( it = m_NodeBuffer->begin( ); it != m_NodeBuffer->end( ); it++ ) { // [0]
                i++;

                if ( 2 != it->num_connected ) { // [1]
                    continue;
                }

                j = it->connected[ 0 ];
                k = it->connected[ 1 ];
                if ( distance_nodes( i, j ) <= 13 ) { // [1]

                    if ( 2 == ( * m_NodeBuffer )[ j ].num_connected ) { // [2]
                        
                        for ( int ind = 0; ind < 2; ind++ ) { // [3]
                            if ( i != ( * m_NodeBuffer )[ j ].connected[ ind ] ) { // [4]
                                tmp = ( * m_NodeBuffer )[ j ].connected[ ind ];
                            }
                        }

                        if ( angle_nodes( i, j, tmp ) > angle_nodes( k, i, j ) ) { // [3]

                            disconnect_nodes ( j, i   );
                            disconnect_nodes ( j, tmp );
                            connect_nodes    ( i, tmp );

                        }


                    } // [2]

                } // [1]
                if ( f_distance_nodes( i, k ) <= 13 ) { // [1]

                    if ( 2 == ( * m_NodeBuffer )[ k ].num_connected ) { // [2]
                        
                        for ( int ind = 0; ind < 2; ind++ ) { // [3]
                            if ( i != ( * m_NodeBuffer )[ k ].connected[ ind ] ) { // [4]
                                tmp = ( * m_NodeBuffer )[ k ].connected[ ind ];
                            }
                        }

                        if ( angle_nodes( i, k, tmp ) > angle_nodes( k, i, j ) ) { // [3]

                            disconnect_nodes ( k, i   );
                            disconnect_nodes ( k, tmp );
                            connect_nodes    ( i, tmp );

                        }


                    } // [2]

                } // [1]


        /*
                // * Delete nodes that doesn't have any connection. * //
                it = m_NodeBuffer->begin( );
                while ( it != m_NodeBuffer->end( ) ) {
                    
                    if ( 0 == it->num_connected ) {
                        it = m_NodeBuffer->erase( it );
                    }
                    else {
                        it++;
                    }

                }
        */

            } // [0]

            return;

        } // END of DeleteNodes METHOD


        // ****************************************************************************** //
        void
            InsertCrossPoints( /* IN_OUT Node_Buffer * m_NodeBuffer, */ )
        // ****************************************************************************** //
        {

            int a, b, c, d;
            int i, j;
            float x, y;
            int num_nodes;
            Node_Buffer::iterator it_old_end = m_NodeBuffer->end( );

            a = -1;
            Node_Buffer::iterator it_a;
            for ( it_a = m_NodeBuffer->begin( ); it_a != ( it_old_end - 1 ); it_a++ ) { // [0]
                a++;

                for ( i = 0; i < it_a->num_connected; i++ ) { // [1]

                    c = a;
                    Node_Buffer::iterator it_c;
                    for ( it_c = ( it_a + 1 ); it_c != it_old_end; it_c++ ) { // [2]
                        c++;

                        for ( j = 0; j < it_c->num_connected; j++ ) { // [3]

                            b = it_a->connected[ i ];
                            d = it_c->connected[ j ];

                            // * Create new node at intersection. * //
                            if ( intersect( a, b, c, d, &x, &y ) ) { // [4]

                                // * Create a new node struct. * //
                                Node node;
                                node.f_x_pos = x;
                                node.f_y_pos = y;
                                node.num_connected = 0;
                                m_NodeBuffer->push_back( node );

                                num_nodes = m_NodeBuffer->size( ) - 1;

                                disconnect_nodes( a, b );
                                disconnect_nodes( c, d );
                                connect_nodes( a, num_nodes );
                                connect_nodes( b, num_nodes );
                                connect_nodes( c, num_nodes );
                                connect_nodes( d, num_nodes );

                            }

                        } // [3]

                    } // [2]

                } // [1]

            } // [0]

            return;

        }; // END of InsertCrossPoints METHOD


        // ****************************************************************************** //
        template < typename T, int W, int H >
        void
            FindCrossings( /* in */ T ( & mWhite )[ H ][ W ], /* in */ T ( & mGreen )[ H ][ W ], FrameGrabber &camFrame/*,T ( & mBallColor )[ H ][ W ], WideAngle_CV * cv*/ /* IN const Trans_Buffer * m_TransBuffer, */ /* IN_OUT Node_Buffer * m_NodeBuffer, */ )
        // ****************************************************************************** //
        {

            // * These threshold are critical to the transition checking! * //
//             const int TotalPixels   = 64;
//             const int IsGreen       = TotalPixels / 2;
//             const int IsWhite       = TotalPixels / 2;
//             const int NoColor       = 5;
//             const int MaxNoColorNum = 2;

            m_L_number = 0;
            m_T_number = 0;
            m_X_number = 0;

            // * Iterate through all the nodes. * //
            int i = -1;
            int j;
//            int k;
//            int XCrossingCounter = 0;
            Node_Buffer::iterator it, it_tmp;
            int  dist;             //<- Distance between nodes.
            int  curX, curY;       //<- Current coordinates of a pixel.
            int  preX, preY;       //<- Previous coordinates of a pixel.
//            int  x, y;
//            int  transCountGW, transCountWG;
            int  transGW, transWG; //<- Transition counter.
            for ( it = m_NodeBuffer->begin( ); it != m_NodeBuffer->end( ); it++ ) { // [0]
                i++;
                j = 1;
                dist = 9999; //<- Just a very large distance for later comparison.
                transGW = 0;
                transWG = 0;

// cijat: try reactivate L-Xings
                //if ( it->num_connected < 3 ) {  // [1] //<- Too few, continue. //!! Discard L crossing for now.
                //    it->crossing_type = Node::CT_Unknown;
                //    continue;
                //}

				// [1] //<- Near the borders, not reliable, continue
				if ( it->x_pos < 5 || it->x_pos > W - 6 || it->y_pos < 9 || it->y_pos > H - 6 ) {
					it->crossing_type = Node::CT_Unknown;
					continue;
					}
                int k = -1;
                for ( it_tmp = m_NodeBuffer->begin( ); it_tmp != m_NodeBuffer->end( ); it_tmp++ ) {
                    k++;

                    if ( it_tmp->num_connected < 1 || it_tmp == it ) {
                        continue;
                    }

                    assert( i != k );
                    dist = min( dist, distance_nodes( i, k ) );

                }
                dist = NimbroStyleTools::round(sqrt( ( float ) dist )/2.f);
				dist = max(4,min(8,dist));

				/*                 // * L or T crossing candidate. * // */
				if ( 2 == it->num_connected ) 
				{  // [1] 


					/*                     // * The angle of L-crossing should be approximately 90 degrees. * // */
					
					tf::Vector3 vecFromCameraToLandmark = soccervision::pixelCameraCorrection(m_NodeBuffer->at( it->connected[ 0 ] ).x_pos, m_NodeBuffer->at( it->connected[ 0 ] ).y_pos);
					tf::Vector3 vecEgoCoordinates = soccervision::compute_ego_position(camFrame.tf_egorot_cameraoptical_OriginBasis, camFrame.tf_egorot_cameraoptical_OriginVector, vecFromCameraToLandmark);			
					Vec2i aworld = Vec2i(static_cast<int>(vecEgoCoordinates.x()), static_cast<int>(vecEgoCoordinates.y()));
					
					vecFromCameraToLandmark = soccervision::pixelCameraCorrection(m_NodeBuffer->at( it->connected[ 1 ] ).x_pos, m_NodeBuffer->at( it->connected[ 1 ] ).y_pos);
					vecEgoCoordinates = soccervision::compute_ego_position(camFrame.tf_egorot_cameraoptical_OriginBasis, camFrame.tf_egorot_cameraoptical_OriginVector, vecFromCameraToLandmark);			
					Vec2i bworld = Vec2i(static_cast<int>(vecEgoCoordinates.x()), static_cast<int>(vecEgoCoordinates.y()));
				
					vecFromCameraToLandmark = soccervision::pixelCameraCorrection(it->x_pos, it->y_pos);
					vecEgoCoordinates = soccervision::compute_ego_position(camFrame.tf_egorot_cameraoptical_OriginBasis, camFrame.tf_egorot_cameraoptical_OriginVector, vecFromCameraToLandmark);			
					Vec2i xingworld = Vec2i(static_cast<int>(vecEgoCoordinates.x()), static_cast<int>(vecEgoCoordinates.y()));
					
					Vec2f adiff = aworld - xingworld; 
					Vec2f bdiff = bworld - xingworld; 
					const float world_ang = NimbroStyleTools::vangle( adiff, bdiff );
					const float angle = fabs( NimbroStyleTools::rad2deg( world_ang ) ); 
					
					if ( angle < 50.f || angle > 130.f ) { 
						it->crossing_type = Node::CT_Unknown; 
						continue; 
					} 
					//cout<<"Angle: " << angle<<endl;
					//it->lambda = bdiff.angle() + world_ang/2.f;

					NimbroStyleTools::TransitionCounter<int,SUB_SAMPLING_HEIGHT,SUB_SAMPLING_WIDTH> tc(dist,mGreen,mWhite/*,cv->ivGoalPostPCCand,cv->ivGoalPostPCCand2*/);
					if(!NimbroStyleTools::bresenham_circle(tc,it->x_pos,it->y_pos,dist)){
						cout<<"Breaking in bresaham_circle"<<endl;
						continue;
					}
					tc.run();

					//cout<<"Transistion Number: " << tc.mTransitionIdxNum<<endl;
					bool hasCorrectTransitionNumber = tc.mTransitionIdxNum == 2;
					if(!hasCorrectTransitionNumber){
						it->crossing_type = Node::CT_Unknown;
						continue;
					}
					Vec2i a,b;
					tc.getLXing(a,b);
					int radius = 1;
					bool isColoredToCenter = true
						&& min(min(it->x_pos,a.x),b.x) >= radius
						&& min(min(it->y_pos,a.y),b.y) >= radius
						&& max(max(it->x_pos,a.x),b.x) <= SUB_SAMPLING_WIDTH -radius
						&& max(max(it->y_pos,a.y),b.y) <= SUB_SAMPLING_HEIGHT-radius
						&& NimbroStyleTools::checkIfColoredOnWholeLine(mWhite,a.x,a.y,it->x_pos,it->y_pos, 0,radius)
						&& NimbroStyleTools::checkIfColoredOnWholeLine(mWhite,b.x,b.y,it->x_pos,it->y_pos, 0,radius);

					if(!isColoredToCenter){
						it->crossing_type = Node::CT_Unknown;
						continue;
					}

					//CM 
					//I guess it's an unnecessary hack, because ballColor is never merged into white, green or black
// 					Vec2i M(it->x_pos, it->y_pos);
// 					int R = 2*sqrt((float)max((a-M).norm2(),(b-M).norm2()));
// 					int num=0,sum=0;
// 					NimbroStyleTools::sumIn2DArrayRelative(mBallColor,sum,num,M,R,R);
// 					if(sum>64){
// 						it->crossing_type = Node::CT_Unknown;
// 						continue;
// 					}

					vecFromCameraToLandmark = soccervision::pixelCameraCorrection(static_cast<float>(a.x), static_cast<float>(a.y));
					vecEgoCoordinates = soccervision::compute_ego_position(camFrame.tf_egorot_cameraoptical_OriginBasis, camFrame.tf_egorot_cameraoptical_OriginVector, vecFromCameraToLandmark);
					aworld = Vec2i(static_cast<int>(vecEgoCoordinates.x()), static_cast<int>(vecEgoCoordinates.y()));
					
					vecFromCameraToLandmark = soccervision::pixelCameraCorrection(static_cast<float>(b.x), static_cast<float>(b.y));
					vecEgoCoordinates = soccervision::compute_ego_position(camFrame.tf_egorot_cameraoptical_OriginBasis, camFrame.tf_egorot_cameraoptical_OriginVector, vecFromCameraToLandmark);
					bworld = Vec2i(static_cast<int>(vecEgoCoordinates.x()), static_cast<int>(vecEgoCoordinates.y()));
					
					adiff = aworld - xingworld;
					bdiff = bworld - xingworld;
					float diffang = NimbroStyleTools::piCut( NimbroStyleTools::vangle( adiff, bdiff ) );
					it->lambda =  NimbroStyleTools::piCut( atan2( ( float ) bdiff.x, ( float ) bdiff.y ) + 0.5f * diffang );
					it->conf = fabs( fabs( diffang ) - ( float ) M_PI_2 );
					it->conf = max( 0.f, it->conf - NimbroStyleTools::deg2rad( 15 ) );        //<- 15 deg deviation from 90 deg is free
					it->conf = max( 0.f, 1.f - it->conf / NimbroStyleTools::deg2rad( 30 ) );  //<- 20 deg reduce the confidence
					it->crossing_type = Node::CT_LXing;
				}
                // * T or X crossing candidate. * //
				else if ( 3 == it->num_connected ) {  // [1]

                    dist = min( dist, ( int ) sqrt( ( float ) distance_nodes( i, it->connected[ 0 ] ) ) / 2 );
                    dist = min( dist, ( int ) sqrt( ( float ) distance_nodes( i, it->connected[ 1 ] ) ) / 2 );
                    dist = min( dist, ( int ) sqrt( ( float ) distance_nodes( i, it->connected[ 2 ] ) ) / 2 );

					tf::Vector3 vecFromCameraToLandmark = soccervision::pixelCameraCorrection(m_NodeBuffer->at( it->connected[ 0 ] ).x_pos, m_NodeBuffer->at( it->connected[ 0 ] ).y_pos);
					tf::Vector3 vecEgoCoordinates = soccervision::compute_ego_position(camFrame.tf_egorot_cameraoptical_OriginBasis, camFrame.tf_egorot_cameraoptical_OriginVector, vecFromCameraToLandmark);			
					const Vec2i aworld = Vec2i(static_cast<int>(vecEgoCoordinates.x()), static_cast<int>(vecEgoCoordinates.y()));
					
					vecFromCameraToLandmark = soccervision::pixelCameraCorrection(m_NodeBuffer->at( it->connected[ 1 ] ).x_pos, m_NodeBuffer->at( it->connected[ 1 ] ).y_pos);
					vecEgoCoordinates = soccervision::compute_ego_position(camFrame.tf_egorot_cameraoptical_OriginBasis, camFrame.tf_egorot_cameraoptical_OriginVector, vecFromCameraToLandmark);			
					const Vec2i bworld = Vec2i(static_cast<int>(vecEgoCoordinates.x()), static_cast<int>(vecEgoCoordinates.y()));
					
					vecFromCameraToLandmark = soccervision::pixelCameraCorrection(m_NodeBuffer->at( it->connected[ 2 ] ).x_pos, m_NodeBuffer->at( it->connected[ 2 ] ).y_pos);
					vecEgoCoordinates = soccervision::compute_ego_position(camFrame.tf_egorot_cameraoptical_OriginBasis, camFrame.tf_egorot_cameraoptical_OriginVector, vecFromCameraToLandmark);			
					const Vec2i cworld = Vec2i(static_cast<int>(vecEgoCoordinates.x()), static_cast<int>(vecEgoCoordinates.y()));
					
					vecFromCameraToLandmark = soccervision::pixelCameraCorrection(it->x_pos, it->y_pos);
					vecEgoCoordinates = soccervision::compute_ego_position(camFrame.tf_egorot_cameraoptical_OriginBasis, camFrame.tf_egorot_cameraoptical_OriginVector, vecFromCameraToLandmark);			
					const Vec2i xingworld = Vec2i(static_cast<int>(vecEgoCoordinates.x()), static_cast<int>(vecEgoCoordinates.y()));
					
					const Vec2i adiff = aworld - xingworld; 
					const Vec2i bdiff = bworld - xingworld; 
					const Vec2i cdiff = cworld - xingworld; 
					const float abang = NimbroStyleTools::vangle( adiff, bdiff );
					const float acang = NimbroStyleTools::vangle( adiff, cdiff );
					const float bcang = NimbroStyleTools::vangle( bdiff, cdiff );
					float tmp[3] = {fabs(abang),fabs(acang),fabs(bcang)};
					sort(tmp,tmp+3);
					float largest = (float)fabs(tmp[2]- M_PI);
					if(largest>M_PI/6)
						continue;
					if(0);
					else if(fabs(fabs(fabs(abang)-M_PI)- largest)<.01f) it->lambda = ((Vec2f)cdiff).angle();
					else if(fabs(fabs(fabs(acang)-M_PI)- largest)<.01f) it->lambda = ((Vec2f)bdiff).angle();
					else if(fabs(fabs(fabs(bcang)-M_PI)- largest)<.01f) it->lambda = ((Vec2f)adiff).angle();
					else continue;


                    // * The length of each branch should be longer than /dist_threshold/ pixels in sub-sampled image.
                    // * OR
                    // * There should be more than one node in all directions of T branches. * //
                    const float dist_threshold = 6.0f * 6.0f;
                    if (   f_distance_nodes( i, it->connected[ 0 ] ) < dist_threshold
                        && m_NodeBuffer->at( it->connected[ 0 ] ).num_connected < 2 ) {
                        continue;
                    }
                    if (   f_distance_nodes( i, it->connected[ 1 ] ) < dist_threshold
                        && m_NodeBuffer->at( it->connected[ 1 ] ).num_connected < 2 ) {
                        continue;
                    }
                    if (   f_distance_nodes( i, it->connected[ 2 ] ) < dist_threshold
                        && m_NodeBuffer->at( it->connected[ 2 ] ).num_connected < 2 ) {
                        continue;
                    }

                    // * All angles of T branches should be larger than some threshold. * //
                    if ( angle_nodes( it->connected[ 0 ], i, it->connected[ 1 ] ) < 40 ) {
                        continue;
                    }
                    if ( angle_nodes( it->connected[ 0 ], i, it->connected[ 2 ] ) < 40 ) {
                        continue;
                    }
                    if ( angle_nodes( it->connected[ 1 ], i, it->connected[ 2 ] ) < 40 ) {
                        continue;
                    }

                    if ( dist < 4 ) { // [2]
                        dist = 4;
                    }
                    else if ( dist > 8 ) { // [2]
                        dist = 8;
                    }

					NimbroStyleTools::TransitionCounter<int,SUB_SAMPLING_HEIGHT,SUB_SAMPLING_WIDTH> tc(dist,mGreen,mWhite/*,cv->ivGoalPostPCCand,cv->ivGoalPostPCCand2*/);
					if(!NimbroStyleTools::bresenham_circle(tc,it->x_pos,it->y_pos,dist)){
						continue;
					}
					tc.run();

					bool hasCorrectTransitionNumber = tc.mTransitionIdxNum == 3;
					if(!hasCorrectTransitionNumber){
						it->crossing_type = Node::CT_Unknown;
						continue;
					}
					Vec2i a,b,c;
					tc.getTXing(a,b,c);
					int radius = 1;
					bool isColoredToCenter = true
						&& min(min(min(it->x_pos,a.x),b.x),c.x) >= radius
						&& min(min(min(it->y_pos,a.y),b.y),c.y) >= radius
						&& max(max(max(it->x_pos,a.x),b.x),c.x) <= SUB_SAMPLING_WIDTH -radius
						&& max(max(max(it->y_pos,a.y),b.y),c.y) <= SUB_SAMPLING_HEIGHT-radius
						&& NimbroStyleTools::checkIfColoredOnWholeLine(mWhite,a.x,a.y,it->x_pos,it->y_pos,0,radius)
						&& NimbroStyleTools::checkIfColoredOnWholeLine(mWhite,c.x,c.y,it->x_pos,it->y_pos,0,radius)
						&& NimbroStyleTools::checkIfColoredOnWholeLine(mWhite,b.x,b.y,it->x_pos,it->y_pos,0,radius);

					if(!isColoredToCenter){
						it->crossing_type = Node::CT_Unknown;
						continue;
					}

// 					Vec2i M(it->x_pos, it->y_pos);
// 					int R = 2*sqrt((float)max((a-M).norm2(),max((b-M).norm2(),(c-M).norm2())));
// 					int num=0,sum=0;
// 					NimbroStyleTools::sumIn2DArrayRelative(mBallColor,sum,num,M,R,R);
// 					if(sum>64){
// 						it->crossing_type = Node::CT_Unknown;
// 						continue;
// 					}

                    it->crossing_type = Node::CT_TXing;
                    m_T_number++;

/*                     if ( 3 == transGW && 3 == transWG ) { // [2] //<- T */
/*                         it->crossing_type = Node::CT_TXing; */
/*                         m_T_number++; */
/*                     } */
/*
 * Sacrifice to make it more reliable.
                    else if ( 4 == transGW && 4 == transWG ) { // [2] //<- X
                        it->crossing_type = 3;
                        m_X_number++;
                    }
*/
/*
                    else { // [2] //<- Not crossing.
                        it->crossing_type = 0;
                    }
*/
                } // [1]

                // * X crossing candidate. * //
                else if ( 4 == it->num_connected ) {  // [1]

//                    it->crossing_type = 3; //<- It seems to be safe to decide it's X here.

                    dist = min( dist, ( int ) sqrt( ( float ) distance_nodes( i, it->connected[ 0 ] ) ) / 2 );
                    dist = min( dist, ( int ) sqrt( ( float ) distance_nodes( i, it->connected[ 1 ] ) ) / 2 );
                    dist = min( dist, ( int ) sqrt( ( float ) distance_nodes( i, it->connected[ 2 ] ) ) / 2 );
                    dist = min( dist, ( int ) sqrt( ( float ) distance_nodes( i, it->connected[ 3 ] ) ) / 2 );

                    if ( dist < 5 ) { // [2]
                        dist = 5;
                    }
                    else if ( dist > 8 ) { // [2]
                        dist = 8;
                    }
                    dist -= 4;

                    // * Walk through the CIRCLE to count Green/White transitions. * //
                    preX = it->x_pos + CIRCLE[ dist ][ j - 1 ][ 0 ];
                    preY = it->y_pos + CIRCLE[ dist ][ j - 1 ][ 1 ];

                    // * Make sure it's inside the image matrix.
                    bool unreliable = false;
                    if ( preX < 1 ) { // [2]
                        preX = 1;
                        unreliable = true;
                        continue;
                    }
                    else if ( preX > W - 2 ) { // [2]
                        preX = W - 2;
                        unreliable = true;
                        continue;
                    }
                    if ( preY < 1 ) { // [2]
                        preY = 1;
                        unreliable = true;
                        continue;
                    }
                    else if ( preY > H - 2 ) { // [2]
                        preY = H - 2;
                        unreliable = true;
                        continue;
                    }
                    int reach_center_num = 0;
                    do { // [2]

                        curX = it->x_pos + CIRCLE[ dist ][ j ][ 0 ];
                        curY = it->y_pos + CIRCLE[ dist ][ j ][ 1 ];

                        // * Make sure it's inside the image matrix.
                        if ( curX < 1 ) { // [3]
                            curX = 1;
                            unreliable = true;
                            break;
                        }
                        else if ( curX > W - 2 ) { // [3]
                            curX = W - 2;
                            unreliable = true;
                            break;
                        }
                        if ( curY < 1 ) { // [3]
                            curY = 1;
                            unreliable = true;
                            break;
                        }
                        else if ( curY > H - 2 ) { // [3]
                            curY = H - 2;
                            unreliable = true;
                            break;
                        }

                        // * Green/Nothing Transitions * //
                        if ( 0 != mGreen[ preY ][ preX ] && 0 == mGreen[ curY ][ curX ] && 0 == mWhite[ curY ][ curX ] ) {
                            unreliable = true;
                            break;
                        }

                        // * Green/White Transitions * //
                        if ( 0 == mWhite[ preY ][ preX ] && 0 != mWhite[ curY ][ curX ] && 0 != mGreen[ preY ][ preX ] ) { // [3]
                            transGW++; //<- One Green/White transition found.

                            // * Check the line back to the center point of the crossing candidate. * //
                            const int max_dis = ( int ) ( sqrt( ( float ) ( ( curX - it->x_pos ) * ( curX - it->x_pos ) + ( curY - it->y_pos ) * ( curY - it->y_pos ) ) ) + 3 );
                            int x = curX;
                            int y = curY;
                            int dis, number;
                            bool reach_crossing = false;
                            for ( int i = 0; i < max_dis; i++ ) {

                                dis = 99;
                                number = 0;
                                int xx[ 8 ];
                                int yy[ 8 ];
                                int ii = 0;
                                // ( 0 )
                                xx[ ii ] = x;
                                yy[ ii ] = y + 1;
                                if ( xx[ ii ] == it->x_pos && yy[ ii ] == it->y_pos ) {
                                    reach_crossing = true;
                                    break;
                                }
                                if ( mWhite[ yy[ ii ] ][ xx[ ii ] ] != 0 ) {
                                    const int tmp_dis = ( int ) ( sqrt( ( ( float ) xx[ ii ] - it->f_x_pos ) * ( ( float ) xx[ ii ] - it->f_x_pos ) + ( ( float ) yy[ ii ] - it->f_y_pos ) * ( ( float ) yy[ ii ] - it->f_y_pos ) ) );
                                    dis = min( dis, tmp_dis );
                                }
                                // ( 1 )
                                ii++;
                                xx[ ii ] = xx[ ii - 1 ] + 1;
                                yy[ ii ] = yy[ ii - 1 ];
                                if ( xx[ ii ] == it->x_pos && yy[ ii ] == it->y_pos ) {
                                    reach_crossing = true;
                                    break;
                                }
                                if ( mWhite[ yy[ ii ] ][ xx[ ii ] ] != 0 ) {
                                    const int tmp_dis = ( int ) ( sqrt( ( ( float ) xx[ ii ] - it->f_x_pos ) * ( ( float ) xx[ ii ] - it->f_x_pos ) + ( ( float ) yy[ ii ] - it->f_y_pos ) * ( ( float ) yy[ ii ] - it->f_y_pos ) ) );
                                    if ( dis > tmp_dis ) {
                                        number = 1;
                                        dis = tmp_dis;
                                    }
                                }
                                // ( 2 )
                                ii++;
                                xx[ ii ] = xx[ ii - 1 ];
                                yy[ ii ] = yy[ ii - 1 ] - 1;
                                if ( xx[ ii ] == it->x_pos && yy[ ii ] == it->y_pos ) {
                                    reach_crossing = true;
                                    break;
                                }
                                if ( mWhite[ yy[ ii ] ][ xx[ ii ] ] != 0 ) {
                                    const int tmp_dis = ( int ) ( sqrt( ( ( float ) xx[ ii ] - it->f_x_pos ) * ( ( float ) xx[ ii ] - it->f_x_pos ) + ( ( float ) yy[ ii ] - it->f_y_pos ) * ( ( float ) yy[ ii ] - it->f_y_pos ) ) );
                                    if ( dis > tmp_dis ) {
                                        number = 2;
                                        dis = tmp_dis;
                                    }
                                }
                                // ( 3 )
                                ii++;
                                xx[ ii ] = xx[ ii - 1 ];
                                yy[ ii ] = yy[ ii - 1 ] - 1;
                                if ( xx[ ii ] == it->x_pos && yy[ ii ] == it->y_pos ) {
                                    reach_crossing = true;
                                    break;
                                }
                                if ( mWhite[ yy[ ii ] ][ xx[ ii ] ] != 0 ) {
                                    const int tmp_dis = ( int ) ( sqrt( ( ( float ) xx[ ii ] - it->f_x_pos ) * ( ( float ) xx[ ii ] - it->f_x_pos ) + ( ( float ) yy[ ii ] - it->f_y_pos ) * ( ( float ) yy[ ii ] - it->f_y_pos ) ) );
                                    if ( dis > tmp_dis ) {
                                        number = 3;
                                        dis = tmp_dis;
                                    }
                                }
                                // ( 4 )
                                ii++;
                                xx[ ii ] = xx[ ii - 1 ] - 1;
                                yy[ ii ] = yy[ ii - 1 ];
                                if ( xx[ ii ] == it->x_pos && yy[ ii ] == it->y_pos ) {
                                    reach_crossing = true;
                                    break;
                                }
                                if ( mWhite[ yy[ ii ] ][ xx[ ii ] ] != 0 ) {
                                    const int tmp_dis = ( int ) ( sqrt( ( ( float ) xx[ ii ] - it->f_x_pos ) * ( ( float ) xx[ ii ] - it->f_x_pos ) + ( ( float ) yy[ ii ] - it->f_y_pos ) * ( ( float ) yy[ ii ] - it->f_y_pos ) ) );
                                    if ( dis > tmp_dis ) {
                                        number = 4;
                                        dis = tmp_dis;
                                    }
                                }
                                // ( 5 )
                                ii++;
                                xx[ ii ] = xx[ ii - 1 ] - 1;
                                yy[ ii ] = yy[ ii - 1 ];
                                if ( xx[ ii ] == it->x_pos && yy[ ii ] == it->y_pos ) {
                                    reach_crossing = true;
                                    break;
                                }
                                if ( mWhite[ yy[ ii ] ][ xx[ ii ] ] != 0 ) {
                                    const int tmp_dis = ( int ) ( sqrt( ( ( float ) xx[ ii ] - it->f_x_pos ) * ( ( float ) xx[ ii ] - it->f_x_pos ) + ( ( float ) yy[ ii ] - it->f_y_pos ) * ( ( float ) yy[ ii ] - it->f_y_pos ) ) );
                                    if ( dis > tmp_dis ) {
                                        number = 5;
                                        dis = tmp_dis;
                                    }
                                }
                                // ( 6 )
                                ii++;
                                xx[ ii ] = xx[ ii - 1 ];
                                yy[ ii ] = yy[ ii - 1 ] + 1;
                                if ( xx[ ii ] == it->x_pos && yy[ ii ] == it->y_pos ) {
                                    reach_crossing = true;
                                    break;
                                }
                                if ( mWhite[ yy[ ii ] ][ xx[ ii ] ] != 0 ) {
                                    const int tmp_dis = ( int ) ( sqrt( ( ( float ) xx[ ii ] - it->f_x_pos ) * ( ( float ) xx[ ii ] - it->f_x_pos ) + ( ( float ) yy[ ii ] - it->f_y_pos ) * ( ( float ) yy[ ii ] - it->f_y_pos ) ) );
                                    if ( dis > tmp_dis ) {
                                        number = 6;
                                        dis = tmp_dis;
                                    }
                                }
                                // ( 7 )
                                ii++;
                                xx[ ii ] = xx[ ii - 1 ];
                                yy[ ii ] = yy[ ii - 1 ] + 1;
                                if ( xx[ ii ] == it->x_pos && yy[ ii ] == it->y_pos ) {
                                    reach_crossing = true;
                                    break;
                                }
                                if ( mWhite[ yy[ ii ] ][ xx[ ii ] ] != 0 ) {
                                    const int tmp_dis = ( int ) ( sqrt( ( ( float ) xx[ ii ] - it->f_x_pos ) * ( ( float ) xx[ ii ] - it->f_x_pos ) + ( ( float ) yy[ ii ] - it->f_y_pos ) * ( ( float ) yy[ ii ] - it->f_y_pos ) ) );
                                    if ( dis > tmp_dis ) {
                                        number = 7;
                                        dis = tmp_dis;
                                    }
                                }

                                x = xx[ number ];
                                y = yy[ number ];

                            }
                            if ( reach_crossing ) {
                                reach_center_num++;
                            }

                        }
                        else if ( 0 != mWhite[ preY ][ preX ] && 0 == mWhite[ curY ][ curX ] && 0 != mGreen[ curY ][ curX ] ) {
                            transWG++; //<- One White/Green transition found.
                        }

                        preX = curX;
                        preY = curY;

                    } while ( 99 != CIRCLE[ dist ][ ++j ][ 0 ] ); // [2]

                    if ( unreliable ) { //<- If the crossing is on the boarder, then the check is unreliable, thus continue.
                        continue;
                    }

                    if ( reach_center_num != 4 ) {
                        continue;
                    }

                    if ( 4 ==  transGW || 4 == transWG ) { // [2] //<- X is relatively more reliable, thus make this transition check lenient.
                        it->crossing_type = Node::CT_XXing;
                        m_X_number++;
                    }
/*
                    else { // [2] //<- Not crossing.
                        it->crossing_type = 0;
                    }
*/

                } // [1]

            } // [0]

            return;

        }; // END of FindCrossings METHOD


        struct LinearGraphComponent{
            typedef pair<int,float> Ending;
            std::vector<int>      mNodes;
            std::vector<int>      mExcludeForFit;
            std::vector<Ending>   mEnds;
            bool                  noSplitNeeded;
            bool                  valid;
            float                 lineAlpha;  // param alpha of hessian parameterisation
            float                 sinAlpha;
            float                 cosAlpha;
            float                 lineR;      // param r     of hessian parameterisation
            inline bool isExcludedFromFit(int i) { return (mExcludeForFit.end() != find(mExcludeForFit.begin(),mExcludeForFit.end(),i));}
			inline Vec2f projectToLine(int x, int y){ return Vec2f(float(x),float(y)) - ornPointDistToFittedLine(x,y)*Vec2f(cosAlpha,sinAlpha); }
            void determineEPLineParams(const Node_Buffer& nb)
			{
				
				const Node& n1 = nb[mEnds[0].first];
				const Node& n2 = nb[mEnds[1].first];
				Vec2f g1(n1.undist_pos);
				Vec2f g2(n2.undist_pos);
				Vec2f n(-(g2.y-g1.y),g2.x-g1.x);
				lineAlpha = atan2(n.y,n.x);
				sinAlpha  = sin(lineAlpha);
				cosAlpha  = cos(lineAlpha);
				lineR     = g1.x*cosAlpha + g1.y*sinAlpha;
			}
			
            void determineEndPoints(const Node_Buffer& nb)
			{
				for(std::vector<int>::iterator it=mNodes.begin();it!=mNodes.end();++it){
					if(nb[*it].num_connected != 2)
						mEnds.push_back(std::make_pair(*it,0.f));
					//else
					//	for(int k=0;k<2;k++){
					//		int neigh = nb[*it].connected[k];
					//		if(find(mNodes.begin(),mNodes.end(),neigh)==mNodes.end()){
					//			mEnds.push_back(std::make_pair(*it,0.f)); // the neigh node was not in components
					//			continue;
					//		}
					//	}
				}
			}
			
            float pointDistToEPLine(int x, int y, const Node_Buffer& nb)
			{ 
				const Node& n1 = nb[mEnds[0].first];
				const Node& n2 = nb[mEnds[1].first];
				Vec2f g1(n1.undist_pos);
				Vec2f g2(n2.undist_pos);
				return NimbroStyleTools::abstandPunktGerade(Vec2f(float(x),float(y)),g1,g2);
			}
            inline float pointDistToFittedLine(int x, int y){ return fabs(ornPointDistToFittedLine(x,y)); }
            inline float ornPointDistToFittedLine(int x, int y){ return x*cosAlpha + y*sinAlpha - lineR; }
            void fitLine(const Node_Buffer& nb)
			{
				Vec2f mu(0,0);
				for(std::vector<int>::iterator it=mNodes.begin();it!=mNodes.end();++it){
					if(isExcludedFromFit(*it)) continue;
					mu += nb[*it].undist_pos; 
				}
				mu/=(float)(mNodes.size()-mExcludeForFit.size());
				float d = 0, n = 0;
				for(std::vector<int>::iterator it=mNodes.begin();it!=mNodes.end();++it){
					if(isExcludedFromFit(*it)) continue;
					float y2 = nb[*it].undist_pos.y - mu.y;  
					float x2 = nb[*it].undist_pos.x - mu.x;
					d += y2*y2 - x2*x2;
					n += y2*x2;
				}
				n*=-2;
				lineAlpha = .5f*atan2(n,d);
				sinAlpha  = sin(lineAlpha);
				cosAlpha  = cos(lineAlpha);
				lineR     = mu.x*cosAlpha + mu.y*sinAlpha;
			}
			
            inline float getUndistSlope(const Node_Buffer& nb, int i, int j){ 
				float div = float(nb[i].undist_pos.x-nb[j].undist_pos.x);
				div = NimbroStyleTools::signum(div) * max(fabs(div),0.01f);
				return (nb[i].undist_pos.y-nb[j].undist_pos.y) / div;
			}
        };

		struct LineCmp{
			LineCmp(ObjectRecognition::Line::Node_Buffer* nb, LinearGraphComponent* lgc) :mNB(nb),mLgc(lgc){}
			ObjectRecognition::Line::Node_Buffer* mNB;
			map<int,Vec2f> mPositionCache;
			inline const Vec2f& getPos(int i){
				map<int,Vec2f>::iterator it = mPositionCache.find(i);
				if( it != mPositionCache.end() )
					return it->second;
				mPositionCache[i] = mLgc->projectToLine( (*mNB)[i].x_pos, (*mNB)[i].y_pos );
				return mPositionCache[i];
			}
			LinearGraphComponent* mLgc; 
			bool operator()(int i, int j){
				const Vec2f& apos = getPos(i);
				const Vec2f& bpos = getPos(j);
				if(apos.x<bpos.x) return true;
				if(apos.x>bpos.x) return false;
				if(apos.y<bpos.y) return true;
				return false;
			}
		};

// 		void printToDot(const char* fn);
        // finds all nodes reachable via degree-two nodes starting at startNode, _excluding_ startNode.
		void findReachableNodes(int startNode, std::vector<int>& reachable, int only_direction=-1, bool remove_first=false)
		{
			reachable.clear();
			std::vector<int> stack;
			stack.push_back(startNode);
			reachable.push_back(startNode);
			int cnt = 0;
			while(!stack.empty()){
				int nidx = stack.back();
				Node& n = (*m_NodeBuffer)[nidx];
				stack.pop_back();
				for(int i=0;i<n.num_connected;i++){
					if(cnt == 0 && only_direction>=0 && i!=only_direction){
						// search only in one direction from start point
						continue;
					}
					int neigh = n.connected[i];
					Node& n2  = (*m_NodeBuffer)[neigh]; // current node
					std::vector<int>::reverse_iterator it = find(reachable.rbegin(),reachable.rend(),neigh);
					if(it!=reachable.rend()){ 
						// prevent circles
						continue;
					}
					if(n2.num_connected > 2){
						// this is a line ending, put it in the list, but do not add it to the stack!
						while(n2.num_connected>0){
							disconnect_nodes(neigh,n2.connected[0]);
						}
						//reachable.push_back(neigh);
						continue;
					}
					// now num_connected is either 1 or 2
					if(n2.num_connected == 2){	
						// if n2 has num_connected == 2, we need to put it on the stack for further investigation
						stack.push_back(neigh);
					}
					reachable.push_back(neigh);  // its _reachable_ OK.
				}
				cnt++;
			}
			if(remove_first)
				reachable.erase(reachable.begin()); // hmpf: expensive!
		}
		
        template < typename T, int W, int H >
        void FindL10nLine(const T (&mWhite)[H][W], FieldLine2* ln_field_lines, int& ln_field_lines_num, const int& max_fieldlines, FrameGrabber &camFrame);
        // ==================================================================================================================================== //


    private:

        // *************************** //
        // * Private Utility Methods * //
        // *************************** //

        // ****************************************************************************** //
        void
            init( /* OUT Trans_Buffer * m_TransBuffer */ )
        // ****************************************************************************** //
        {
            // * Initialize acos lookup table. * //
            int i;
            float f;

            for ( i = 0; i < MAX_COS; i++ ) {
                f = ( float ) ( i * 1.0 / ( float ) MAX_COS );
                m_TransBuffer->arc_cos_sqare[ i ] = ( int ) ( ( 180.0 / 3.1416 ) * acos( sqrt( f ) ) );
            }

            return;

        }; // END of init_m_TransBufferfer METHOD


        int get_neighbour_excl(Node& n, int not_thisone, int nidx=0){
			int cnt=0;
            for(int i=0;i<n.num_connected;i++)
				if(n.connected[i]!=not_thisone){
					if(cnt++==nidx)
						return n.connected[i];
				}
                    
            return -1;
        }


        // ****************************************************************************** //
        bool
            is_connected ( /* IN const Node_Buffer * m_NodeBuffer, */ /* in */ const int i, /* in */ const int j )
        // ****************************************************************************** //
        {
            /*
            * Cancel this safty check for higher efficiency.

                if ( m_NodeBuffer->empty( ) ) {
                return false;
            }
            */

            for ( int k = 0; k < ( * m_NodeBuffer )[ i ].num_connected; k++ ) {
                if ( ( * m_NodeBuffer )[ i ].connected[ k ] == j ) {
                    return true;
                }
            }
            return false;

        }; // END of is_connected METHOD


        // ****************************************************************************** //
        bool
            connect_nodes ( /* IN_OUT Node_Buffer * m_NodeBuffer, */ /* in */ const int i, /* in */ const int j )
        // ****************************************************************************** //
        {
            /*
            * Cancel this safty check for higher efficiency.

            if ( m_NodeBuffer->empty( ) ) {
                return false;
            }
            */

            if ( i == j ) {
                return false;
            }

            if ( ( ( * m_NodeBuffer )[ i ].num_connected == MAX_CONN ) || ( ( * m_NodeBuffer )[ j ].num_connected == MAX_CONN ) ) {
                return false;
            }
            ( * m_NodeBuffer )[ i ].connected[ ( * m_NodeBuffer )[ i ].num_connected++ ] = j;
            ( * m_NodeBuffer )[ j ].connected[ ( * m_NodeBuffer )[ j ].num_connected++ ] = i;

            return true;

        }; // END of connect_nodes METHOD


        // ****************************************************************************** //
        int
            disconnect_nodes ( /* IN_OUT Node_Buffer * m_NodeBuffer, */ /* in */ const int i, /* in */ const int j )
        // ****************************************************************************** //
        {
            int ip, jp;

            if ( i == j ) {
                return false;
            }

            /* Detect Positions (in the connectio-array) of the edges to delete */
            for ( ip = 0; ip < ( * m_NodeBuffer )[ i ].num_connected; ip++ ) {
                if ( ( * m_NodeBuffer )[ i ].connected[ ip ] == j ) {
                    break;
                }
            }
            if ( ip == ( * m_NodeBuffer )[ i ].num_connected ) {
                return false;
            }
            for ( jp = 0; jp < ( * m_NodeBuffer )[ j ].num_connected; jp++ ) {
                if ( ( * m_NodeBuffer )[ j ].connected[ jp ] == i ) {
                    break;
                }
            }
            if ( jp == ( * m_NodeBuffer )[ j ].num_connected ) {
                return false;
            }
            /* Overwrite edge-indicators to delete with last entry in the array, decrement its length */
            ( * m_NodeBuffer )[ i ].connected[ ip ] = ( * m_NodeBuffer )[ i ].connected[ --( ( * m_NodeBuffer )[ i ].num_connected ) ];
            ( * m_NodeBuffer )[ j ].connected[ jp ] = ( * m_NodeBuffer )[ j ].connected[ --( ( * m_NodeBuffer )[ j ].num_connected ) ];

            return true;

        }; // END of disconnect_nodes METHOD


        // ****************************************************************************** //
        int
            angle_nodes ( /* IN const Trans_Buffer * m_TransBuffer, */ /* IN const Node_Buffer *  m_NodeBuffer, */ /* in */ const int i, /* in */ const int j, /* in */ const int k )
        // ****************************************************************************** //
        {
            int xl;
            int yl;
            int xr;
            int yr;
            long int xlq;
            long int ylq;
            long int xrq;
            long int yrq;
            long int res_z, res_c;
            long int res_n, res;

            xl = ( ( * m_NodeBuffer )[ i ].x_pos - ( * m_NodeBuffer )[ j ].x_pos );
            yl = ( ( * m_NodeBuffer )[ i ].y_pos - ( * m_NodeBuffer )[ j ].y_pos );
            xr = ( ( * m_NodeBuffer )[ k ].x_pos - ( * m_NodeBuffer )[ j ].x_pos );
            yr = ( ( * m_NodeBuffer )[ k ].y_pos - ( * m_NodeBuffer )[ j ].y_pos );

            res_z = xl * xr + yl * yr;
            xlq = xl * xl;
            ylq = yl * yl;
            xrq = xr * xr;
            yrq = yr * yr;
            res_n = ( ( xlq + ylq ) * ( xrq + yrq ) );

            if ( res_n > 0 ) {
                res_c = ( 511 * ( res_z * res_z ) ) / res_n;
            }
            else {
                res_c = 511;
            }
            if ( res_z >= 0 ) {
                res = ( m_TransBuffer->arc_cos_sqare[ res_c ] );
            }
            else {
                res = ( 180 - m_TransBuffer->arc_cos_sqare[ res_c ] );
            }
            return ( int ) res;

        }; // END of angle_nodes METHOD


        // ****************************************************************************** //
        float
            f_angle_nodes ( /* IN const Trans_Buffer * m_TransBuffer, */ /* IN const Node_Buffer *  m_NodeBuffer, */ /* in */ const int i, /* in */ const int j, /* in */ const int k )
        // ****************************************************************************** //
        {
            float xl;
            float yl;
            float xr;
            float yr;
            double xlq;
            double ylq;
            double xrq;
            double yrq;
            double res_z, res_c;
            double res_n, res;

            xl = ( ( * m_NodeBuffer )[ i ].f_x_pos - ( * m_NodeBuffer )[ j ].f_x_pos );
            yl = ( ( * m_NodeBuffer )[ i ].f_y_pos - ( * m_NodeBuffer )[ j ].f_y_pos );
            xr = ( ( * m_NodeBuffer )[ k ].f_x_pos - ( * m_NodeBuffer )[ j ].f_x_pos );
            yr = ( ( * m_NodeBuffer )[ k ].f_y_pos - ( * m_NodeBuffer )[ j ].f_y_pos );

            res_z = xl * xr + yl * yr;
            xlq = xl * xl;
            ylq = yl * yl;
            xrq = xr * xr;
            yrq = yr * yr;
            res_n = ( ( xlq + ylq ) * ( xrq + yrq ) );

            if ( res_n > 0 ) {
                res_c = ( 511 * ( res_z * res_z ) ) / res_n;
            }
            else {
                res_c = 511;
            }
            if ( res_z >= 0 ) {
                res = ( m_TransBuffer->arc_cos_sqare[ ( int ) res_c ] );
            }
            else {
                res = ( 180 - m_TransBuffer->arc_cos_sqare[ ( int ) res_c ] );

            }
            return ( float ) res;

        }; // END of f_angle_nodes METHOD


        // ****************************************************************************** //
        int
            distance_nodes ( /* IN const Node_Buffer * m_NodeBuffer, */ /* in */ const int i, /* in */ const int j )
        // ****************************************************************************** //
        {
            int x_dist, y_dist;

            x_dist = ( ( * m_NodeBuffer )[ i ].x_pos - ( * m_NodeBuffer )[ j ].x_pos );
            y_dist = ( ( * m_NodeBuffer )[ i ].y_pos - ( * m_NodeBuffer )[ j ].y_pos );

            return ( x_dist * x_dist ) + ( y_dist * y_dist );

        }; // END of distance_nodes METHOD


        // ****************************************************************************** //
        float
            f_distance_nodes( /* IN const Node_Buffer * m_NodeBuffer, */ /* in */ const int i, /* in */ const int j )
        // ****************************************************************************** //
        {
            float x_dist, y_dist;

            x_dist = ( ( * m_NodeBuffer )[ i ].f_x_pos - ( * m_NodeBuffer )[ j ].f_x_pos );
            y_dist = ( ( * m_NodeBuffer )[ i ].f_y_pos - ( * m_NodeBuffer )[ j ].f_y_pos );

            return ( x_dist * x_dist ) + ( y_dist * y_dist );

        }; // END of f_distance_nodes METHOD


        // ****************************************************************************** //
        int
            closes_loop ( /* IN const Node_Buffer * m_NodeBuffer, */ /* in */ const int i, /* in */ const int j )
        // ****************************************************************************** //
        {
            int k, l;
            int num_i, num_j;

            num_i = ( * m_NodeBuffer )[ i ].num_connected;
            num_j = ( * m_NodeBuffer )[ j ].num_connected;

            for ( k = 0; k < num_i; k++ ) {
                for ( l = 0; l < num_j; l++ ) {
                    if ( ( * m_NodeBuffer )[ i ].connected[ k ] == ( * m_NodeBuffer )[ j ].connected[ l ] ) {
                        return 1;
                    }
                }
            }
            return 0;

        }; // END of closes_loop METHOD


        // ****************************************************************************** //
        template < typename T, int W, int H >
        int
            black_line_value ( /* in */ const T ( & matrix )[ H ][ W ], /* IN const Node_Buffer * m_NodeBuffer, */ /* in */ const int i, /* in */ const int j )
        // ****************************************************************************** //
        {
            int xm;
            int ym;
            int vm, vij;
            int res;

            // * Compute coordinates of pixel (and its grey-value) in between node_i and node_j * //
            xm = ( ( ( * m_NodeBuffer )[ i ].x_pos + ( * m_NodeBuffer )[ j ].x_pos + 1 ) >> 1 );
            ym = ( ( ( * m_NodeBuffer )[ i ].y_pos + ( * m_NodeBuffer )[ j ].y_pos + 1 ) >> 1 );
            vm = matrix[ ym ][ xm ];

            // * Compute sum of grey-values of node_i and node_j and pixel in between * //
            vij = vm + matrix[ ( * m_NodeBuffer )[ i ].y_pos ][ ( * m_NodeBuffer )[ i ].x_pos ] + matrix[ ( * m_NodeBuffer )[ j ].y_pos ][ ( * m_NodeBuffer )[ j ].x_pos ];

            if ( vij == 0 ) {
                return 0;
            }
            // * Compute res in (0, 63). The larger res is, the darker is the middle pixel,
            // * compared to the average. (=Desired case) * //
            res = ( min( 63, ( vm * 189 ) / vij ) );

            return ( res * res ) >> 2;

        }; // END of back_line_value METHOD


        // ****************************************************************************** //
        template < typename T, int W, int H >
        void
            update_close_nodes( /* in */ const T ( & matrix )[ H ][ W ], /* IN const Trans_Buffer * m_TransBuffer, */ /* IN_OUT Node_Buffer * m_NodeBuffer, */ /* in */ const int i )
        // ****************************************************************************** //
        {
            int j, k;
            int ang, fac;

            /* See: find_close_nodes */
            if ( ( * m_NodeBuffer )[ i ].num_connected > 2 ) {
                ( * m_NodeBuffer )[ i ].num_close = 0;
                return;
            }
            fac = ( H >> 2 ) + LINE_WIDTH * 2;

            if ( ( ( * m_NodeBuffer )[ i ].num_connected == 2 ) &&
                ( angle_nodes( ( * m_NodeBuffer )[ i ].connected[ 0 ], i, ( * m_NodeBuffer )[ i ].connected[ 1 ] ) > 90 ) ) {
                    ( * m_NodeBuffer )[ i ].num_close = 0;
                    return;
            }
            k = 0;
            while ( k < ( * m_NodeBuffer )[ i ].num_close ) {
                j = ( * m_NodeBuffer )[ i ].close_id[ k ];
                ang = 120;
                if ( ( ( * m_NodeBuffer )[ j ].num_connected == MAX_CONN ) ||
                    is_connected( i, j ) ||
                    closes_loop( i, j ) ||
                    ( ( ( * m_NodeBuffer )[ i ].num_connected == 1 ) && ( ( ang = angle_nodes( ( * m_NodeBuffer )[ i ].connected[ 0 ], i, j ) ) < 60 ) ) ||
                    ( ( ( * m_NodeBuffer )[ i ].num_connected == 2 ) && ( ( ang = min( angle_nodes( ( * m_NodeBuffer )[ i ].connected[ 0 ], i, j ),
                                                                                   angle_nodes( ( * m_NodeBuffer )[ i ].connected[ 1 ], i, j ) ) ) < 60 ) ) ) {
                        ( * m_NodeBuffer )[ i ].num_close--;
                        ( * m_NodeBuffer )[ i ].close_id[ k ] = ( * m_NodeBuffer )[ i ].close_id[ ( * m_NodeBuffer )[ i ].num_close ];
                }
                else {
                    ( * m_NodeBuffer )[ i ].close_adj[ k ] = fac * ( ang - 60 ) *
                        black_line_value( matrix, i, j ) / ( distance_nodes( i, j ) + 1 );
                    k++;
                }
            }

        }; // END of update_close_nodes METHOD


        // ****************************************************************************** //
        bool
            intersect( /* IN const Node_Buffer * m_NodeBuffer, */ /* in */ const int a, /* in */ const int b, /* in */ const int c, /* in */ const int d, /* out */ float * x, /* out */ float * y )
        // ****************************************************************************** //
        {
            float xa, xb, xc, xd;
            float ya, yb, yc, yd;
            float dx1, dx2, dy1, dy2;
            float nenn;
            float beta;
            float alpha;

            if ( ( a == b ) || ( c == d ) || ( a == c ) || ( a == d ) || ( b == c ) || ( b == d ) ) {
                return false;
            }

            xa = ( * m_NodeBuffer )[ a ].f_x_pos;
            ya = ( * m_NodeBuffer )[ a ].f_y_pos;
            xb = ( * m_NodeBuffer )[ b ].f_x_pos;
            yb = ( * m_NodeBuffer )[ b ].f_y_pos;
            xc = ( * m_NodeBuffer )[ c ].f_x_pos;
            yc = ( * m_NodeBuffer )[ c ].f_y_pos;
            xd = ( * m_NodeBuffer )[ d ].f_x_pos;
            yd = ( * m_NodeBuffer )[ d ].f_y_pos;

            if ( ( max( xa, xb ) < min( xc, xd ) ) || ( max( xc, xd ) < min( xa, xb ) ) ||
                 ( max( ya, yb ) < min( yc, yd ) ) || ( max( yc, yd ) < min( ya, yb ) )    ) {
                    return false;
            }

            dx1 = xb - xa;
            dy1 = yb - ya;
            dx2 = xd - xc;
            dy2 = yd - yc;

            nenn = dy2 * dx1 - dx2 * dy1;

            if ( nenn == 0 ) {
                return false;
            }

            beta = ( float ) ( ya * dx1 - yc * dx1 + xc * dy1 - xa * dy1 ) / ( float ) ( nenn );

            if ( ( beta <= 0 ) || ( beta >= 1 ) ) {
                return false;
            }

            if ( dx1 != 0 ) {
                alpha = ( xc - xa + dx2 * beta ) / ( float ) ( dx1 );
            }
            else if ( dy1 != 0 ) {
                alpha = ( yc - ya + dy2 * beta ) / ( float ) ( dy1 );
            }
            else {
                alpha = 0;
            }

            if ( ( alpha <= 0 ) || ( alpha >= 1 ) ) {
                return false;
            }

            * x = xc + ( float ) ( dx2 ) * beta;
            * y = yc + ( float ) ( dy2 ) * beta;

            return true;

        }; // END of intersect METHOD


        // ****************************************************************************** //
        void 
            bresenham( int x1, int y1, int x2, int y2 )
        // ****************************************************************************** //
        {
            // * Use Bresenham algorithm to generate straight lines. * //

            int slope;
            int dx, dy, incE, incNE, d, x, y;
            // Reverse lines where x1 > x2
            if ( x1 > x2 ) {
                bresenham( x2, y2, x1, y1 );
                return;
            }
            dx = x2 - x1;
            dy = y2 - y1;
            // Adjust y-increment for negatively sloped lines
            if ( dy < 0 ) {
                slope = -1;
                dy = -dy;
            }
            else {
                slope = 1;
            }

            // Bresenham constants
            incE = 2 * dy;
            incNE = 2 * dy - 2 * dx;
            d = 2 * dy - dx;
            y = y1;
            // Blit
            for ( x = x1; x <= x2; x++ ) {

                m_FieldBoundary[ x ] = y;
                m_BoundaryForLine[ x ] = y;
                if ( d <= 0 ) {
                    d += incE;
                }
                else {
                    d += incNE;
                    y += slope;
                }
            }

            return;

        }; // END of bresenham


    }; // END of Line CLASS

// // void
// // Line::printToDot(const char* fn){
// // 	std::ofstream os(fn);
// // 	os  << "graph G{"<<std::endl;
// // 
// // 	int cnt=0;
// // 	// nodes
// // 	for(std::vector<Node>::iterator it=m_NodeBuffer->begin();it!=m_NodeBuffer->end();++it,++cnt){
// // 		int pa = it->x_pos*30;
// // 		int pb = it->y_pos*30;
// // 		os<<"n"<<cnt<<" [label=\""<<cnt<< "\", pos=\""<<pa<<","<<pb<<"\"];"<<std::endl;
// // 	}
// // 
// // 	cnt = 0;
// // 	// connections
// // 	for(std::vector<Node>::iterator it=m_NodeBuffer->begin();it!=m_NodeBuffer->end();++it,++cnt){
// // 		Node& n = *it;
// // 		for(int i=0;i<n.num_connected;i++){
// // // 			Node& n2 = (*m_NodeBuffer)[n.connected[i]];
// // 			os<<"n"<<cnt<<" -- n"<<n.connected[i]<<";"<<std::endl;
// // 		}
// // 	}
// // 	os << "}"<<std::endl;
// // }


template < typename T, int W, int H >
void 
Line::FindL10nLine(const T (&mWhite)[H][W], FieldLine2* ln_field_lines, int& ln_field_lines_num, const int& max_fieldlines, FrameGrabber &camFrame){ // find a line to use for l10n.
    ln_field_lines_num = 0;
    std::vector<int> seen;
	m_Components.clear();
#if FIELDLINE_DEBUG_INFO
	printToDot("initial.dot");
#endif
    for (unsigned int i1 = 0; i1 < m_NodeBuffer->size(); ++i1) 
    {   // * find connected components of degree-two-nodes * //
        if((*m_NodeBuffer)[i1].num_connected!=2) 
            continue;   // we are looking for lines, that is, connected degree-two-nodes
        if(seen.end() != find(seen.begin(),seen.end(),i1)) 
            continue;   // this node is part of a previous component
        LinearGraphComponent lgc;
        findReachableNodes(i1,lgc.mNodes);
        if(lgc.mNodes.size()>=8){               // ignore tiny components
            lgc.valid = true;
            m_Components.push_back(lgc);   // save component
        }
        copy(lgc.mNodes.begin(),lgc.mNodes.end(),std::back_inserter(seen)); // mark all in reachable as seen
    }
#if FIELDLINE_DEBUG_INFO
	printToDot("afterfindcomp.dot");
#endif
	static bool splitCritereonDistToEPLine = true; 
    for(std::vector<LinearGraphComponent>::iterator comp_it = m_Components.begin();comp_it!=m_Components.end();++comp_it)
    {    // * find the two nodes which have only one neighbour in the set * //
        LinearGraphComponent& comp = *comp_it;
        if(!comp.valid) continue;
        comp.determineEndPoints(*m_NodeBuffer);
		if(     comp.mEnds.size() == 1  // some weird structure
			||  comp.mEnds.size()  > 2  // even weirder! 
			|| (splitCritereonDistToEPLine && comp.mEnds.size()==0)){ // a circle, and Endpoint-Line critereon does not support splitting it
            comp.valid = false;
            continue;
        }
        comp.noSplitNeeded = false; // we may need to split this one.
    }
	static int RTC = -1;
	//CM
	//was just ++RTC but that is ambigious 
	RTC = (RTC+1) % max(1,static_cast<int>(m_Components.size()));
	int RTCcnt = -1;
    for(std::vector<LinearGraphComponent>::iterator comp_it = m_Components.begin();comp_it!=m_Components.end();++comp_it)
    {    // * calculate undistorted coordinates * //
        LinearGraphComponent& comp = *comp_it;
        if(!comp.valid) continue;
		RTCcnt ++;
        for(std::vector<int>::iterator it=comp.mNodes.begin();it!=comp.mNodes.end();++it){
            Node& n = (*m_NodeBuffer)[*it];
			
			tf::Vector3 vecFromCameraToLandmark = soccervision::pixelCameraCorrection(n.x_pos, n.y_pos);
			tf::Vector3 vecEgoCoordinates = soccervision::compute_ego_position(camFrame.tf_egorot_cameraoptical_OriginBasis, camFrame.tf_egorot_cameraoptical_OriginVector, vecFromCameraToLandmark);			
            n.undist_pos.x = NimbroStyleTools::round(NimbroStyleTools::undistCamPlaneX_to_undistCamPixelX(static_cast<float>(vecEgoCoordinates.x())));
            n.undist_pos.y = NimbroStyleTools::round(NimbroStyleTools::undistCamPlaneY_to_undistCamPixelY(static_cast<float>(vecEgoCoordinates.y())));
#if FIELDLINE_DEBUG_INFO
			if(RTC == RTCcnt){
				//for(std::vector<int>::iterator it2=comp.mNodes.begin();it2!=comp.mNodes.end();++it2){
				//	Node& n2 = (*m_NodeBuffer)[*it2];
				//	cv->ivDebugLines.push_back(make_pair(Vec2i(n.x_pos,n.y_pos),Vec2i(n2.x_pos,n2.y_pos)));
				//}
				cv->ivGoalPostPCCand2.push_back(Vec2f(n.x_pos,n.y_pos));
			}
            //cv->ivGoalPostPCCand2.push_back(Vec2f(n.undist_pos.x+SUB_SAMPLING_WIDTH/2,n.undist_pos.y));
#endif
        }
    }
    bool split = true;
    while(split)
    {   
        split=false;
        for(std::vector<LinearGraphComponent>::iterator comp_it = m_Components.begin();comp_it!=m_Components.end();++comp_it)
        {   // * split segments into two segments if necessary * //        
            LinearGraphComponent& comp = *comp_it;
            if(comp.noSplitNeeded) continue;
            if(!comp.valid)        continue;

            float max_dist=-1.f;
            int   max_dist_node;
			float min_dist_for_split = 3;
			if(splitCritereonDistToEPLine){
				min_dist_for_split = 3;
				// Splitting strategy:
				// - project all points onto the line between the endpoints, 
				// - select the node with maximum distance
				for(std::vector<int>::iterator it=comp.mNodes.begin();it!=comp.mNodes.end();++it){
					Node& node    = (*m_NodeBuffer)[*it];
					float d       = comp.pointDistToEPLine(node.undist_pos.x,node.undist_pos.y,*m_NodeBuffer);
					if(max_dist<d){
						max_dist = d;
						max_dist_node = *it;
					}
				}
			}else{
				min_dist_for_split = M_PI/2;
				// Splitting strategy:
				// - determine curvature at every point on the line
				// - select the node with maximum curvature
				// DO NOT USE: components have different opinions on connectivity than the nodes!
				for(std::vector<int>::iterator it=comp.mNodes.begin();it!=comp.mNodes.end();++it){
					Node& node    = (*m_NodeBuffer)[*it];
					if(node.num_connected!=2)
						continue;
					Node& A = (*m_NodeBuffer)[node.connected[0]];
					Node& C = (*m_NodeBuffer)[node.connected[1]];
					float ang = M_PI - fabs(NimbroStyleTools::vangle(A.undist_pos-node.undist_pos, C.undist_pos-node.undist_pos));
					if(max_dist<ang){
						max_dist      = ang;
						max_dist_node = *it;
					}
				}
			}
            if(max_dist<0){
                comp.noSplitNeeded = true;
                continue;
            }
			if(comp.mEnds.size()==0){
				Node& nsplit   = (*m_NodeBuffer)[max_dist_node];
				comp.mEnds.push_back(std::make_pair(max_dist_node,0.f));
				comp.mEnds.push_back(std::make_pair(nsplit.connected[0],0.f));
				disconnect_nodes(max_dist_node,nsplit.connected[0]);
				split = true;
				continue;
			}
			if(comp.mEnds.size()!=2){
				comp.valid = false;
				comp.noSplitNeeded = true;
				continue;
			}
            comp.determineEPLineParams(*m_NodeBuffer);
            //comp.fitLine(*m_NodeBuffer);
            Node& nsplit   = (*m_NodeBuffer)[max_dist_node];
			if(min_dist_for_split < max_dist /*&& comp.mEnds[0].second == 0*/)
            {    // huh, we need to split this one.
                LinearGraphComponent lgc1,lgc2;
				findReachableNodes(max_dist_node,lgc1.mNodes,0,true);
				findReachableNodes(max_dist_node,lgc2.mNodes,1,true);
				if(lgc1.mNodes.size()>lgc2.mNodes.size()){
					disconnect_nodes(max_dist_node,nsplit.connected[0]);
					lgc2.mNodes.push_back(max_dist_node);
				}
				else if(nsplit.num_connected>1){
					disconnect_nodes(max_dist_node,nsplit.connected[1]);
					lgc1.mNodes.push_back(max_dist_node);
				}
				lgc1.determineEndPoints(*m_NodeBuffer);
				lgc2.determineEndPoints(*m_NodeBuffer);

#if FIELDLINE_DEBUG_INFO
				cv->ivGoalPostPCCand.push_back(Vec2i(nsplit.x_pos,nsplit.y_pos));
#endif
                lgc1.valid = (lgc1.mNodes.size()>3);
                lgc2.valid = (lgc2.mNodes.size()>3);
				lgc1.valid &= lgc1.mEnds.size()==2;
				lgc2.valid &= lgc2.mEnds.size()==2;
				if(lgc1.valid){
					lgc1.valid &= lgc1.mEnds[0].first != -1;
					lgc1.valid &= lgc1.mEnds[1].first != -1;
				}
				if(lgc2.valid){
					lgc2.valid &= lgc2.mEnds[0].first != -1;
					lgc2.valid &= lgc2.mEnds[1].first != -1;
				}

                lgc1.noSplitNeeded = false;
                lgc2.noSplitNeeded = false;
                if(lgc1.valid ^ lgc2.valid){
                    comp = lgc1.valid ? lgc1 : lgc2;
                    split = true;
                    continue;
                }else if(!lgc1.valid && !lgc2.valid){
                    comp.valid = false;
                    continue;
                }else{
                    split = true;
                    comp = lgc1;
                    m_Components.push_back(lgc2);
                    break; // need to restart, since vector modified!
                }
            }
            comp.noSplitNeeded = true;
        }
    }
#if FIELDLINE_DEBUG_INFO
	printToDot("aftersplit.dot");
#endif
    for(std::vector<LinearGraphComponent>::iterator comp_it = m_Components.begin();comp_it!=m_Components.end();++comp_it)
    {    // * remove endpoints and do a least-squares fit * //
        LinearGraphComponent& comp = *comp_it;
        if(!comp.valid)        continue;
        comp.mExcludeForFit.push_back(comp.mEnds[0].first);
        comp.mExcludeForFit.push_back(comp.mEnds[1].first);
        comp.fitLine(*m_NodeBuffer);
        for(unsigned int kickout=0;kickout<(comp.mNodes.size()-2)/5;kickout++){
            float max_dist = -1;
            int   max_dist_node;
            for(std::vector<int>::iterator it=comp.mNodes.begin();it!=comp.mNodes.end();++it){
                if(comp.isExcludedFromFit(*it)) continue;
                Node& node    = (*m_NodeBuffer)[*it];
                float d       = comp.pointDistToFittedLine(node.undist_pos.x,node.undist_pos.y);// TODO: UNDIST
                if(d>max_dist){
                    max_dist = d;
                    max_dist_node = *it;
                }
            }
#if FIELDLINE_DEBUG_INFO
            //cv->ivGoalPostPCCand.push_back(Vec2i((*m_NodeBuffer)[max_dist_node].x_pos,(*m_NodeBuffer)[max_dist_node].y_pos));
#endif
            comp.mExcludeForFit.push_back(max_dist_node);
            comp.fitLine(*m_NodeBuffer);
        }
    }
	bool merge = true;
	while(merge){
		merge = false;
		for(std::vector<LinearGraphComponent>::iterator comp_it = m_Components.begin();comp_it!=m_Components.end();++comp_it){
			LinearGraphComponent& comp = *comp_it;
			if(!comp.valid)        continue;
			for(std::vector<LinearGraphComponent>::iterator comp_it2 = m_Components.begin();comp_it2!=m_Components.end();++comp_it2){
				if(comp_it2 == comp_it) continue;
				LinearGraphComponent& comp2 = *comp_it2;
				if(!comp2.valid)        continue;
				float angdiff = NimbroStyleTools::rad2deg( fabs(NimbroStyleTools::piCut(comp.lineAlpha-comp2.lineAlpha)) );
				if(angdiff > 90.f) 
					angdiff = fabs(angdiff - 180); 
				if(    angdiff > 10.f ) continue;
				if(fabs(fabs(comp.lineR)-fabs(comp2.lineR)) >= 3) continue;

				Node& n00 = (*m_NodeBuffer)[comp.mEnds[0].first];
				Node& n01 = (*m_NodeBuffer)[comp.mEnds[1].first];
				Node& n10 = (*m_NodeBuffer)[comp2.mEnds[0].first];
				Node& n11 = (*m_NodeBuffer)[comp2.mEnds[1].first];
				int smallest_id = 0;
				float f,fmax;
				fmax = (float)n00.undist_pos.dist2(n10.undist_pos);
				f = (float)n00.undist_pos.dist2(n11.undist_pos);
				if( f < fmax) { fmax=f; smallest_id = 1;}
				f = (float)n01.undist_pos.dist2(n10.undist_pos);
				if( f < fmax) { fmax=f; smallest_id = 2;}
				f = (float)n01.undist_pos.dist2(n11.undist_pos);
				if( f < fmax) { fmax=f; smallest_id = 3;}

				if(fmax > 30*30) continue;
				merge = true;
				comp2.valid = false;
				copy(comp2.mNodes.begin(),comp2.mNodes.end(),std::back_inserter(comp.mNodes));


				switch(smallest_id){
					case 0: comp.mEnds[0] = comp.mEnds[1]; comp.mEnds[1] = comp2.mEnds[1]; break;
					case 1: comp.mEnds[0] = comp.mEnds[1]; comp.mEnds[1] = comp2.mEnds[0]; break;
					case 2: /*comp.mEnds[0] = comp.mEnds[0];*/ comp.mEnds[1] = comp2.mEnds[1]; break;
					case 3: /*comp.mEnds[0] = comp.mEnds[0];*/ comp.mEnds[1] = comp2.mEnds[0]; break;
				}
				break;
			}
			if(merge) 
				break;
		}
	}

    for(std::vector<LinearGraphComponent>::iterator comp_it = m_Components.begin();comp_it!=m_Components.end();++comp_it)
    {
        LinearGraphComponent& comp = *comp_it;
        if(!comp.valid)        continue;
        Node& nstart = (*m_NodeBuffer)[comp.mEnds[0].first];
        Node& nend   = (*m_NodeBuffer)[comp.mEnds[1].first];
        Vec2f p1 = comp.projectToLine(nstart.undist_pos.x,nstart.undist_pos.y);
        Vec2f p2 = comp.projectToLine(nend.undist_pos.x,nend.undist_pos.y);
		Vec2f w1 = Vec2f(NimbroStyleTools::undistCamPixelX_to_undistCamPlaneX(p1.x), NimbroStyleTools::undistCamPixelY_to_undistCamPlaneY(p1.y));
		Vec2f w2 = Vec2f(NimbroStyleTools::undistCamPixelX_to_undistCamPlaneX(p2.x), NimbroStyleTools::undistCamPixelY_to_undistCamPlaneY(p2.x));
		//if(++RTCcnt==RTC){
		//	vector<int>::const_iterator nit    = comp.mNodes.begin();
		//	vector<int>::const_iterator nitend = comp.mNodes.end();
		//	for(;nit!=nitend;nit++){
		//		cv->ivGoalPostPCCand2.push_back(Vec2i(
		//			(*m_NodeBuffer)[*nit].x_pos,
		//			(*m_NodeBuffer)[*nit].y_pos));
		//	}
		//}

		// sort nodes according to x/y position. Useful for displaying and determining curvature
		LineCmp linecmp(m_NodeBuffer,&comp);
		sort(comp.mNodes.begin(),comp.mNodes.end(),linecmp);
#if 0
		float curvature = 0;
		float lastSlope = comp.getUndistSlope(*m_NodeBuffer, 0,1);
		for(int i=1;i<comp.mNodes.size()-1;i++){
			float slope = comp.getUndistSlope(*m_NodeBuffer,i,i+1);
			curvature += slope-lastSlope;
			lastSlope = slope;
		}
		curvature /= comp.mNodes.size()-1;
#else
		float curvature = 
			NimbroStyleTools::abstandPunktGerade(
			  (*m_NodeBuffer)[comp.mNodes[comp.mNodes.size()/2]].undist_pos,
			  nstart.undist_pos,nend.undist_pos)
			/(nstart.undist_pos-nend.undist_pos).norm();
#endif
		bool eliminateZigZagLines = true;
		if(eliminateZigZagLines){
			for(int i=0;i<((int)comp.mNodes.size())-2; ++i){
				Vec2i p0 = (*m_NodeBuffer)[comp.mNodes[i+0]].undist_pos;
				Vec2i p1 = (*m_NodeBuffer)[comp.mNodes[i+1]].undist_pos;
				Vec2i p2 = (*m_NodeBuffer)[comp.mNodes[i+2]].undist_pos;
				if((p0-p1).norm2() > 2 * (p0-p2).norm2()){
					comp.valid = false;
				}
			}
		}
		
		Vec2i vec_1 = Vec2i(NimbroStyleTools::round(p1.x+SUB_SAMPLING_WIDTH/2),NimbroStyleTools::round(p1.y));
		Vec2i vec_2 = Vec2i(NimbroStyleTools::round(p2.x+SUB_SAMPLING_WIDTH/2),NimbroStyleTools::round(p2.y));
		Vec2i vec_3 = Vec2i(NimbroStyleTools::round(w1.x),NimbroStyleTools::round(w1.y));
		Vec2i vec_4 = Vec2i(NimbroStyleTools::round(w2.x),NimbroStyleTools::round(w2.y));
		
		FieldLine2 fl(0, vec_1, vec_2, vec_3, vec_4);
		
		fl.mNodes = &comp;
		fl.curvature = curvature;
        ln_field_lines[ln_field_lines_num++] = fl;
        if(ln_field_lines_num>=max_fieldlines)
            break;
    }
}

}; // END of ObjectRecognition NAMESPACE




#endif // END of OBJECT_RECOGNITION_LINE_H


//------------------------------------------------------------------------------------------------------------------//
//                      Line Detection Class Interface - Part of ObjectRecognition namespace                        //
//------------------------------------------------------------------------------------------------------------------//

// ******************************** //
// * Public Methods ( Interface ) * //
// ******************************** //

//        export template < typename T, int W, int H >
//        void 
//        ScanBoundary ( /* in */ const T ( & mGreen )[ H ][ W ] );


//        export template < typename T, int W, int H >
//        void
//        Smooth ( /* in_out */ T ( & matrix )[ H ][ W ], /* out_temp */ T ( & tmp )[ H ][ W ] );


//        export template < typename T, int W, int H >
//        void
//        RetrieveSkeleton ( /* in */ const T ( & matrix )[ H ][ W ], /* out */ T ( & output )[ H ][ W ] );


//        export template < typename T, int W, int H >
//        void
//        FindNodes ( /* in_out */ T ( & matrix )[ H ][ W ], /* out_temp */ T ( & tmp )[ H ][ W ] /* OUT Node_Buffer * m_NodeBuffer, */ );


//        export template < typename T, int W, int H >
//        void
//        ConnectTouchingNodes ( /* in */ const T ( & matrix )[ H ][ W ] /* IN_OUT Node_Buffer * m_NodeBuffer, */ );


//        export template < typename T, int W, int H >
//        void
//        FindMoreNodes ( /* in */ const T ( & matrix )[ H ][ W ] /* IN_OUT Node_Buffer * m_NodeBuffer, */ );


//        export template < typename T, int W, int H >
//        void
//        FindCloseNodes ( /* in */ const T ( & matrix )[ H ][ W ] /* IN const Trans_Buffer * m_TransBuffer, */ /* IN_OUT Node_Buffer * m_NodeBuffer, */ );


//        export template < typename T, int W, int H >
//        void
//        ConnectCloseNodes ( /* in */ const T ( & matrix )[ H ][ W ] /* IN const Trans_Buffer * m_TransBuffer, */ /* IN_OUT Node_Buffer * m_NodeBuffer, */ );


//        void
//        SmoothNodes ( /* IN_OUT Node_Buffer * m_NodeBuffer, */ );


//        void
//        DeleteNodes ( /* IN const Trans_Buffer * m_TransBuffer, */ /* IN_OUT Node_Buffer * m_NodeBuffer, */ /* in */ const int H );


//        void
//        InsertCrossPoints( /* IN_OUT Node_Buffer * m_NodeBuffer, */ );


//        export template < typename T, int W, int H >
//        void
//        FindCrossings( /* in */ const T ( & mWhite )[ H ][ W ], /* in */ const T ( & mGreen )[ H ][ W ] /* IN const Trans_Buffer * m_TransBuffer, */ /* IN_OUT Node_Buffer * m_NodeBuffer, */ );


// *************************** //
// * Private Utility Methods * //
// *************************** //

//        void
//        init   ( /* OUT Trans_Buffer * m_TransBuffer */ );

//        bool 
//        is_connected       ( /* IN const Node_Buffer * m_NodeBuffer, */   /* in */ const int i, /* in */ const int j );

//        bool
//        connect_nodes      ( /* IN_OUT Node_Buffer * m_NodeBuffer, */     /* in */ const int i, /* in */ const int j );

//        int
//        disconnect_nodes   ( /* IN_OUT Node_Buffer * m_NodeBuffer, */     /* in */ const int i, /* in */ const int j );

//        int
//        distance_nodes     ( /* IN const Node_Buffer * m_NodeBuffer, */   /* in */ const int i, /* in */ const int j );

//        float
//        f_distance_nodes   ( /* IN const Node_Buffer * m_NodeBuffer, */   /* in */ const int i, /* in */ const int j );

//        int
//        closes_loop        ( /* IN const Node_Buffer * m_NodeBuffer, */   /* in */ const int i, /* in */ const int j );

//        int
//        angle_nodes        ( /* IN const Trans_Buffer * m_TransBuffer, */ /* IN const Node_Buffer *  m_NodeBuffer, */ /* in */ const int i, /* in */ const int j, /* in */ const int k );

//        float
//        f_angle_nodes      ( /* IN const Trans_Buffer * m_TransBuffer, */ /* IN const Node_Buffer *  m_NodeBuffer, */ /* in */ const int i, /* in */ const int j, /* in */ const int k );

//        bool
//        intersect          ( /* IN const Node_Buffer * m_NodeBuffer, */ /* in */ const int a, /* in */ const int b, /* in */ const int c, /* in */ const int d, /* out */ float * x, /* out */ float * y );

//        export template < typename T, int W, int H >
//        int
//        black_line_value   ( /* in */ const T ( & matrix )[ H ][ W ], /* IN const Node_Buffer * m_NodeBuffer, */ /* in */ const int i, /* in */ const int j );

//        export template < typename T, int W, int H >
//        void
//        update_close_nodes ( /* in */ const T ( & matrix )[ H ][ W ], /* IN const Trans_Buffer * m_TransBuffer, */ /* IN_OUT Node_Buffer * m_NodeBuffer, */ /* in */ const int i );
